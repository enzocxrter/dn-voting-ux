<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Dn Brotato Taterz Farm</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Dn Brotato Taterz Farm" />

    <link rel="icon" href="fabicon.png" />

    <style>
      @font-face {
        font-family: "OverstreetBibleBold";
        src: url("assets/fonts/overstreetbiblebold.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "OverstreetBibleBold", system-ui, -apple-system,
          BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #ffffff;
        background: url("assets/images/background2.png") center center / cover
          no-repeat fixed;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .page {
        width: 100%;
        max-width: 1200px;
        padding: 20px 16px 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* HEADER / LOGO BAR */
      .header {
        width: 100%;
        height: 100px;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0;
      }

      .header-link {
        display: inline-block;
      }

      .header-logo {
        height: 80px;
        width: auto;
        transition: transform 0.3s ease;
      }

      .header-logo:hover {
        transform: scale(1.05);
      }

      /* TITLE */
      h1 {
        margin: 60px 0 40px;
        text-align: center;
        font-size: clamp(2.5rem, 5vw, 4.5rem);
        line-height: 1.1;
        text-transform: uppercase;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        color: #000000;
      }

      /* CONNECT SECTION */
      .connect-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      }

      .connect-btn {
        border: none;
        padding: 0;
        background: transparent;
        cursor: pointer;
        display: block;
        width: 260px;
        height: 80px;
        background-image: url("assets/images/connect.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .connect-btn:hover {
        background-image: url("assets/images/connecthover.png");
        transform: scale(1.15);
      }

      .connect-btn:active {
        transform: scale(0.98);
      }

      .connect-hover-text {
        margin-top: 16px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #f5f5f5;
        font-size: 2rem;
        opacity: 0;
        transform: translateY(8px);
        transition:
          opacity 0.2s ease-out,
          transform 0.2s ease-out;
        pointer-events: none;
      }

      .connect-wrapper:hover .connect-hover-text {
        opacity: 1;
        transform: translateY(0);
      }

      /* NOT VERIFIED STATE */
      .not-verified {
        margin-top: 24px;
        text-align: center;
        font-size: 1.4rem;
      }

      .verify-button {
        margin-top: 12px;
        display: inline-block;
        padding: 10px 24px;
        border-radius: 999px;
        background: #000000;
        color: #ffffff;
        text-decoration: none;
        text-transform: uppercase;
        font-size: 1.2rem;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.6);
      }

      /* VOTING STATION */
      .voting-station {
        margin-top: 20px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #ffffff;
      }

      .voting-layout {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        justify-content: center;
      }

      .voting-content {
        flex: 1;
        min-width: 0;
      }

      .voting-title {
        font-size: clamp(2rem, 4vw, 3rem);
        text-transform: uppercase;
        margin-bottom: 16px;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
      }

      /* PoH status + rank pill */
      .poh-status {
        margin-bottom: 20px;
        font-size: 1.6rem;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      }

      .poh-status-label {
        color: #ffffff;
      }

      .poh-status-yes {
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 6px #000,
          0 0 10px #000;
      }

      .poh-rank {
        font-size: 1.6rem;
        padding: 4px 12px;
        border-radius: 999px;
        background: rgba(18, 206, 236, 0.2);
        border: 1px solid rgba(0, 255, 232, 0.7);
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 8px #000,
          0 0 12px #000;
      }

      .vote-stats {
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-size: 1.4rem;
        margin-bottom: 24px;
      }

      .vote-stat-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(0, 0, 0, 0.45);
        padding: 10px 16px;
        border-radius: 10px;
      }

      .vote-stat-label {
        text-align: left;
      }

      .vote-stat-value {
        text-align: right;
      }

      .vote-action {
        margin-top: 10px;
        font-size: 1.6rem;
      }

      .vote-btn {
        border: none;
        padding: 0;
        background: transparent;
        cursor: pointer;
        display: inline-block;
        width: 220px;
        height: 70px;
        background-image: url("assets/images/vote.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .vote-btn:hover {
        background-image: url("assets/images/votehover.png");
        transform: scale(1.15);
      }

      .vote-btn:active {
        transform: scale(0.98);
      }

      .no-votes-text {
        font-size: 1.6rem;
        opacity: 0.9;
      }

      /* LEFT SIDE: VOTE THERMOMETER */
      .thermo-wrapper {
        width: 200px;
        padding: 16px 12px 20px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 20px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
        text-align: center;
      }

      .thermo-title {
        font-size: 1.4rem;
        text-transform: uppercase;
        margin-bottom: 12px;
      }

      .thermo-body {
        position: relative;
        width: 90px;
        height: 460px;
        margin: 0 auto 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .thermo-column {
        position: relative;
        width: 36px;
        height: 340px;
        margin-top: 6px;
        border-radius: 999px;
        border: 4px solid rgba(255, 255, 255, 0.9);
        overflow: hidden;
        background: linear-gradient(
          to top,
          rgba(255, 255, 255, 0.12),
          rgba(255, 255, 255, 0.25)
        );
      }

      .thermo-mercury {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 0%;
        background: linear-gradient(
          to top,
          #12ceec,
          #00ffe8
        );
        box-shadow: 0 0 12px rgba(0, 255, 232, 0.8);
        transition: height 0.6s ease-out;
      }

      .thermo-bulb {
        width: 56px;
        height: 56px;
        border-radius: 999px;
        border: 4px solid rgba(255, 255, 255, 0.95);
        background: radial-gradient(
          circle at 30% 30%,
          #00ffe8,
          #12ceec
        );
        box-shadow: 0 0 18px rgba(0, 255, 232, 0.7);
        margin-top: -6px;
      }

      .thermo-face {
        position: absolute;
        left: 50%;
        width: 78px;
        height: 78px;
        border-radius: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.9);
        bottom: 20px;
        transition: bottom 0.6s ease-out;
        z-index: 2;
      }

      .thermo-face img {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        object-fit: contain;
      }

      .thermo-face-goal {
        position: absolute;
        left: 50%;
        width: 78px;
        height: 78px;
        border-radius: 50%;
        transform: translateX(-50%);
        top: -6px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.9);
        z-index: 2;
      }

      .thermo-face-goal img {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        object-fit: contain;
      }

      .thermo-labels {
        font-size: 1.05rem;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      #thermoCount {
        font-size: 1.3rem;
      }

      #thermoPercent {
        font-size: 1rem;
        opacity: 0.9;
      }

      .thermo-target {
        font-size: 0.9rem;
        opacity: 0.7;
      }

      /* LEADERBOARD */
      .leaderboard {
        margin-top: 40px;
        width: 100%;
        max-width: 600px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 16px;
        padding: 16px 20px 24px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.8);
      }

      .leaderboard-title {
        font-size: 1.8rem;
        text-transform: uppercase;
        margin-bottom: 12px;
        text-align: center;
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 1.2rem;
      }

      .leaderboard-table th,
      .leaderboard-table td {
        padding: 8px 10px;
        text-align: left;
      }

      .leaderboard-table th {
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        opacity: 0.9;
      }

      .leaderboard-table tr:nth-child(even) td {
        background: rgba(255, 255, 255, 0.03);
      }

      .leaderboard-table td.rank-col {
        width: 40px;
      }

      .leaderboard-table td.title-col {
        width: 200px;
      }

      .leaderboard-table td.votes-col {
        text-align: right;
        width: 120px;
      }

      .leaderboard-row-me td {
        background: rgba(18, 206, 236, 0.18) !important;
        font-weight: 600;
      }

      @media (max-width: 600px) {
        .header {
          height: 80px;
        }

        .header-logo {
          height: 60px;
        }

        .connect-btn {
          width: 220px;
          height: 70px;
        }

        h1 {
          margin-top: 40px;
        }

        .connect-hover-text {
          font-size: 1.6rem;
        }

        .vote-stats {
          font-size: 1.2rem;
        }

        .vote-btn,
        .no-votes-text {
          font-size: 1.4rem;
        }

        .poh-status {
          font-size: 1.4rem;
        }

        .voting-layout {
          flex-direction: column;
          align-items: center;
        }

        .thermo-wrapper {
          width: 220px;
        }
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>

  <body>
    <div class="page">
      <header class="header">
        <a
          href="https://www.davydonothing.com"
          target="_blank"
          rel="noopener noreferrer"
          class="header-link"
        >
          <img
            src="assets/images/dnlogo2.png"
            alt="DN Brotato logo"
            class="header-logo"
          />
        </a>
      </header>

      <h1>DN Voting Platform</h1>

      <!-- STATE 1: CONNECT (shown initially) -->
      <div class="connect-wrapper" id="connectSection">
        <button
          class="connect-btn"
          id="connectWalletButton"
          aria-label="Connect Wallet"
        ></button>

        <div class="connect-hover-text">
          <p>Connect your wallet to vote on SERIOUS topics</p>
        </div>
      </div>

      <!-- STATE 2: NOT POH VERIFIED -->
      <div class="not-verified hidden" id="notVerifiedSection">
        <p>This wallet is not PoH verified yet.</p>
        <a
          href="#"
          target="_blank"
          rel="noopener noreferrer"
          class="verify-button"
          id="verifyLink"
        >
          Verify Here
        </a>
      </div>

      <!-- STATE 3: VOTING STATION -->
      <div class="voting-station hidden" id="votingSection">
        <div class="voting-layout">
          <!-- LEFT: Vote Thermometer -->
          <div class="thermo-wrapper">
            <div class="thermo-title">Vote Heat</div>

            <div class="thermo-body">
              <div class="thermo-column">
                <div class="thermo-mercury" id="thermoMercury"></div>
              </div>
              <div class="thermo-bulb"></div>

              <div class="thermo-face-goal">
                <img src="assets/images/DevlanBald.png" alt="Devlan bald" />
              </div>

              <div class="thermo-face" id="thermoFace">
                <img src="assets/images/Devlan.png" alt="Devlan face" />
              </div>
            </div>

            <div class="thermo-labels">
              <div id="thermoCount">0</div>
              <div id="thermoPercent">0% to target</div>
              <div class="thermo-target" id="thermoTarget">
                Target: 5,000 votes
              </div>
            </div>
          </div>

          <!-- RIGHT: Vote content -->
          <div class="voting-content">
            <div class="voting-title">Voting station</div>

            <div class="poh-status">
              <span class="poh-status-label">Proof of Humanity verified:</span>
              <span class="poh-status-yes" id="pohStatusYes">Yes</span>
              <span class="poh-rank hidden" id="userRankLabel"></span>
            </div>

            <div class="vote-stats">
              <div class="vote-stat-row">
                <div class="vote-stat-label">Total votes (global)</div>
                <div class="vote-stat-value" id="totalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Your total votes</div>
                <div class="vote-stat-value" id="userTotalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Votes today</div>
                <div class="vote-stat-value" id="votesToday">0/10</div>
              </div>
            </div>

            <div class="vote-action" id="voteAction"></div>
          </div>
        </div>
      </div>

      <!-- LEADERBOARD -->
      <div class="leaderboard" id="leaderboardSection">
        <div class="leaderboard-title">Top Voters</div>
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th class="rank-col">#</th>
              <th class="title-col">Title</th>
              <th>Wallet</th>
              <th class="votes-col">Total Votes</th>
            </tr>
          </thead>
          <tbody id="leaderboardBody">
            <tr>
              <td colspan="4">No votes yet. Be the first to vote.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

   <!-- Ethers v6 UMD -->
<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

<script>
  // ==========================
  //  CONFIG / CONSTANTS
  // ==========================

  // Mainnet voting / TATERZ contract
  const CONTRACT_ADDRESS = "0xBE817fd849FbF8DBd07840F2F3a89F2D649994A3";

  // Minimal ABI for the DN voting + TATERZ contract.
  // Some view functions may not exist on-chain yet; all calls are wrapped in try/catch.
  const CONTRACT_ABI = [
    // Core action: each vote is a TATERZ claim + a vote
    "function vote(bytes signature)",

    // Config / global
    "function maxVotesPerDay() view returns (uint8)",
    "function taterzPerVote() view returns (uint256)",
    "function totalVotesGlobal() view returns (uint256)",

    // User info (newer version)
    "function getUserInfo(address user) view returns (uint64 dayIndex, uint8 votesToday, uint256 totalVotes, uint256 tokensClaimed, uint8 votesLeft)",

    // Fallback / older helpers (if present)
    "function votesLeftToday(address user) view returns (uint8)",
    "function totalVotesOf(address user) view returns (uint256)",

    // Optional target votes (if contract has it)
    "function targetVotes() view returns (uint256)"
  ];

  // Linea Proof-of-Humanity HTTP gate (UX level)
  const POH_API_BASE = "https://poh-api.linea.build/poh/v2";

  // Linea PoH signer API for on-chain verification
  const POH_SIGNER_API_BASE = "https://poh-signer-api.linea.build/poh/v2";

  // Where to send non-PoH users to complete verification
  const POH_PORTAL_URL = "https://linea.build/hub/apps/sumsub-reusable-identity";

  // Linea mainnet chain ID
  const LINEA_CHAIN_ID = 59144n;
  const LINEA_CHAIN_ID_HEX = "0xe708";

  // Fallback target vote goal if on-chain value is missing
  const DEFAULT_TARGET_VOTES = 5000;

  // ==========================
  //  GLOBAL STATE
  // ==========================

  let provider = null;
  let signer = null;
  let contract = null;
  let currentAccount = null;
  let isPohVerified = null;

  // connectButton modes:
  // "connect"  -> normal connect
  // "verify"   -> opens PoH portal
  // "connected"-> wallet + PoH OK, app open
  let connectButtonMode = "connect";

  // ==========================
  //  DOM HELPERS
  // ==========================

  function setError(message) {
    const el = document.getElementById("errorBox");
    if (el) {
      el.textContent = message || "";
      el.style.display = message ? "block" : "none";
    } else if (message) {
      console.error("Error:", message);
    }
  }

  function setSuccess(message) {
    const el = document.getElementById("successBox");
    if (el) {
      el.textContent = message || "";
      el.style.display = message ? "block" : "none";
    } else if (message) {
      console.log("Success:", message);
    }
  }

  function setConnectingState(isConnecting) {
    const btn = document.getElementById("connectButton");
    if (!btn) return;
    if (isConnecting) {
      btn.disabled = true;
      btn.textContent = "Connecting…";
    } else {
      btn.disabled = false;
      if (connectButtonMode === "connect") btn.textContent = "Connect Wallet";
      if (connectButtonMode === "verify") btn.textContent = "Verify PoH";
      if (connectButtonMode === "connected") btn.textContent = "Connected";
    }
  }

  function setVoteButtonBusy(isBusy) {
    const btn = document.getElementById("voteButton");
    if (!btn) return;
    btn.disabled = isBusy;
    btn.textContent = isBusy ? "Voting…" : "Vote";
  }

  function showAppMain() {
    const gate = document.getElementById("gateSection");
    const main = document.getElementById("appMain");
    if (gate) gate.style.display = "none";
    if (main) main.style.display = "block";
  }

  function showGateOnly() {
    const gate = document.getElementById("gateSection");
    const main = document.getElementById("appMain");
    if (gate) gate.style.display = "block";
    if (main) main.style.display = "none";
  }

  function updateAddressDisplay(addr) {
    const el = document.getElementById("walletAddressDisplay");
    if (!el) return;
    if (!addr) {
      el.textContent = "Not connected";
    } else {
      el.textContent = `${addr.slice(0, 6)}...${addr.slice(-4)}`;
    }
  }

  // ==========================
  //  ETH / PROVIDER HELPERS
  // ==========================

  async function ensureProviderAndContract() {
    if (!window.ethereum) {
      throw new Error("MetaMask not found");
    }
    if (!provider) {
      provider = new ethers.BrowserProvider(window.ethereum);
    }
    if (!signer) {
      signer = await provider.getSigner();
    }
    if (!contract) {
      contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
    }
    return { provider, signer, contract };
  }

  async function ensureLineaNetwork() {
    if (!window.ethereum) return false;
    const netProvider = new ethers.BrowserProvider(window.ethereum);
    const net = await netProvider.getNetwork();
    return net.chainId === LINEA_CHAIN_ID;
  }

  // ==========================
  //  PROOF OF HUMANITY (HTTP)
  // ==========================

  async function checkPohOffchain(address) {
    try {
      console.log("Checking PoH via HTTP for", address);
      const res = await fetch(`${POH_API_BASE}/${address}`);
      if (!res.ok) {
        throw new Error(`PoH HTTP ${res.status}`);
      }
      const text = (await res.text()).trim(); // "true" or "false"
      const isHuman = text === "true";
      console.log("PoH API result:", isHuman);
      return isHuman;
    } catch (err) {
      console.error("PoH API error:", err);
      return null; // "couldn't check"
    }
  }

  // ==========================
  //  STATE REFRESH
  // ==========================

  async function refreshUserAndGlobalState() {
    if (!currentAccount) return;

    try {
      const { provider, signer, contract } = await ensureProviderAndContract();

      // ----- GLOBAL -----
      let maxVotesPerDay = 10;
      let totalVotesGlobal = 0;
      let targetVotes = DEFAULT_TARGET_VOTES;

      try {
        const maxVotesBn = await contract.maxVotesPerDay();
        maxVotesPerDay = Number(maxVotesBn);
      } catch (e) {
        console.warn("maxVotesPerDay read failed, using default 10", e);
      }

      try {
        const totalGlobalBn = await contract.totalVotesGlobal();
        totalVotesGlobal = Number(totalGlobalBn);
      } catch (e) {
        console.warn("totalVotesGlobal read failed", e);
      }

      try {
        const targetBn = await contract.targetVotes();
        targetVotes = Number(targetBn);
      } catch (e) {
        // If contract has no targetVotes, just keep default
        console.warn("targetVotes read failed, using fallback", e);
      }

      const totalVotesEl = document.getElementById("totalVotesValue");
      if (totalVotesEl) {
        totalVotesEl.textContent = totalVotesGlobal.toLocaleString();
      }

      // If you have a progress bar, update it here
      const progressBar = document.getElementById("votesProgressBarFill");
      const progressText = document.getElementById("votesProgressText");
      if (progressBar) {
        const pct =
          targetVotes > 0
            ? Math.min(100, (totalVotesGlobal * 100) / targetVotes)
            : 0;
        progressBar.style.width = `${pct.toFixed(1)}%`;
      }
      if (progressText) {
        progressText.textContent = `${totalVotesGlobal.toLocaleString()} / ${targetVotes.toLocaleString()} votes`;
      }

      // ----- PER-USER -----
      let votesLeft = null;
      let votesToday = null;
      let totalVotesUser = null;

      // Preferred: single getUserInfo()
      try {
        const info = await contract.getUserInfo(currentAccount);
        // info = [dayIndex, votesToday, totalVotes, tokensClaimed, votesLeft]
        votesToday = Number(info[1]);
        totalVotesUser = Number(info[2]);
        votesLeft = Number(info[4]);
      } catch (e) {
        console.warn("getUserInfo read failed, falling back", e);
        // Fallback: separate calls
        try {
          const left = await contract.votesLeftToday(currentAccount);
          votesLeft = Number(left);
        } catch (e2) {
          console.warn("votesLeftToday read failed", e2);
        }
        try {
          const total = await contract.totalVotesOf(currentAccount);
          totalVotesUser = Number(total);
        } catch (e3) {
          console.warn("totalVotesOf read failed", e3);
        }
      }

      // Update "Claimable votes" (we treat this as total votes user has so far)
      const claimableEl = document.getElementById("claimableVotesValue");
      if (claimableEl && totalVotesUser != null) {
        claimableEl.textContent = totalVotesUser.toString();
      }

      // Update "Claims left today" (now "Votes left today")
      const leftEl = document.getElementById("claimsLeftTodayValue");
      if (leftEl && votesLeft != null) {
        leftEl.textContent = `${votesLeft} / ${maxVotesPerDay}`;
      }

      // Show/hide vote button based on votesLeft
      const voteBtn = document.getElementById("voteButton");
      const usedAllMsg = document.getElementById("usedAllVotesMessage");
      if (voteBtn && usedAllMsg) {
        if (votesLeft === null) {
          // Unknown, keep button but warn
          voteBtn.style.display = "inline-flex";
          usedAllMsg.style.display = "none";
        } else if (votesLeft > 0) {
          voteBtn.style.display = "inline-flex";
          usedAllMsg.style.display = "none";
        } else {
          voteBtn.style.display = "none";
          usedAllMsg.style.display = "block";
          usedAllMsg.textContent =
            "You’ve used all votes for now. Come back later.";
        }
      }
    } catch (err) {
      console.error("Error reading user/global state:", err);
      // Soft-fail UX
      const voteBtn = document.getElementById("voteButton");
      const usedAllMsg = document.getElementById("usedAllVotesMessage");
      if (voteBtn && usedAllMsg) {
        voteBtn.style.display = "none";
        usedAllMsg.style.display = "block";
        usedAllMsg.textContent =
          "Could not load claim/vote data. Check console or try again.";
      }
    }
  }

  // ==========================
  //  CONNECT FLOW (HTTP POH GATE)
  // ==========================

  async function handleConnectClick() {
    setError("");
    setSuccess("");

    if (connectButtonMode === "verify") {
      // User already failed PoH, connect button becomes a "Verify" button
      window.open(POH_PORTAL_URL, "_blank");
      return;
    }

    if (!window.ethereum) {
      setError("MetaMask not found. Please install it to continue.");
      return;
    }

    setConnectingState(true);

    try {
      const accounts = await window.ethereum.request({
        method: "eth_requestAccounts",
      });

      if (!accounts || !accounts.length) {
        setError("No wallet selected.");
        return;
      }

      currentAccount = accounts[0];
      window.currentAccount = currentAccount; // for debugging in console
      updateAddressDisplay(currentAccount);

      // Check PoH via HTTP
      const pohResult = await checkPohOffchain(currentAccount);
      if (pohResult === true) {
        isPohVerified = true;
        connectButtonMode = "connected";
        setConnectingState(false);
        showAppMain();

        // Initialize provider/contract + state
        await ensureProviderAndContract();
        await refreshUserAndGlobalState();
      } else if (pohResult === false) {
        isPohVerified = false;
        connectButtonMode = "verify";
        setConnectingState(false);
        showGateOnly();
        setError(
          "This wallet is not Proof-of-Humanity verified. Click 'Verify PoH' to complete verification."
        );
      } else {
        // pohResult === null (API failure)
        isPohVerified = null;
        connectButtonMode = "connect";
        setConnectingState(false);
        showGateOnly();
        setError("Could not check Proof of Humanity. Please try again.");
      }
    } catch (err) {
      console.error("Connect/init error:", err);
      setError("Failed to connect wallet. Check console for details.");
      setConnectingState(false);
    }
  }

  // ==========================
  //  VOTE (ON-CHAIN POH)
  // ==========================

  async function onVoteClick() {
    setError("");
    setSuccess("");

    try {
      if (!window.ethereum) {
        setError("MetaMask not found.");
        return;
      }
      if (!currentAccount) {
        setError("Connect your wallet first.");
        return;
      }

      const { provider, signer, contract } = await ensureProviderAndContract();

      // Ensure user is actually on Linea mainnet
      const net = await provider.getNetwork();
      if (net.chainId !== LINEA_CHAIN_ID) {
        setError("Please switch your wallet network to Linea.");
        return;
      }

      // Optional UX guard: require HTTP PoH to be true
      if (isPohVerified === false) {
        setError("This wallet is not PoH verified via Linea. Complete PoH first.");
        return;
      }

      setVoteButtonBusy(true);

      // Get PoH signature for on-chain verification
      const sigRes = await fetch(`${POH_SIGNER_API_BASE}/${currentAccount}`);
      if (!sigRes.ok) {
        throw new Error(`PoH signer HTTP ${sigRes.status}`);
      }
      const rawSig = (await sigRes.text()).trim();
      if (!rawSig || !rawSig.startsWith("0x")) {
        throw new Error("Invalid PoH signature format");
      }
      const pohSignature = rawSig;

      // Send vote transaction (vote + TATERZ claim)
      const tx = await contract.vote(pohSignature);
      await tx.wait();

      setSuccess("Vote successful! Your TATERZ claim has been recorded.");
      await refreshUserAndGlobalState();
    } catch (err) {
      console.error("Vote tx error:", err);
      const rawMsg =
        err?.error?.message ||
        err?.data?.message ||
        err?.reason ||
        err?.message ||
        String(err ?? "");
      const lower = rawMsg.toLowerCase();

      if (err?.code === "ACTION_REJECTED" || lower.includes("user rejected")) {
        setError("Transaction rejected in wallet.");
      } else if (lower.includes("notpohverified") || lower.includes("not poh verified")) {
        setError(
          "This wallet is not PoH-verified according to Linea's on-chain verifier. Complete PoH with this wallet."
        );
      } else if (lower.includes("daily") && lower.includes("limit")) {
        setError("You’ve used all votes for now. Come back later.");
      } else if (lower.includes("not enough taterz") || lower.includes("insufficient taterz")) {
        setError(
          "Voting contract does not have enough TATERZ to pay rewards. Please contact the team."
        );
      } else if (
        lower.includes("ecdsa: invalid signature length") ||
        lower.includes("invalid signature")
      ) {
        setError(
          "PoH signature from Linea was invalid. Please refresh the page and try again."
        );
      } else if (lower.includes("signer http")) {
        setError(
          "Could not fetch PoH signature from Linea signer API. Please try again in a moment."
        );
      } else {
        setError("Vote transaction failed. Check console for details.");
      }
    } finally {
      setVoteButtonBusy(false);
    }
  }

  // ==========================
  //  AUTO-WIRING & EVENTS
  // ==========================

  function wireDomEvents() {
    const connectBtn = document.getElementById("connectButton");
    if (connectBtn) {
      connectBtn.addEventListener("click", handleConnectClick);
    }

    const voteBtn = document.getElementById("voteButton");
    if (voteBtn) {
      voteBtn.addEventListener("click", onVoteClick);
    }
  }

  function setupWalletEventListeners() {
    if (!window.ethereum) return;

    window.ethereum.on("accountsChanged", async (accounts) => {
      setError("");
      setSuccess("");

      if (!accounts || !accounts.length) {
        // Wallet disconnected
        currentAccount = null;
        contract = null;
        signer = null;
        provider = null;
        connectButtonMode = "connect";
        setConnectingState(false);
        showGateOnly();
        updateAddressDisplay(null);

        const voteBtn = document.getElementById("voteButton");
        const usedAllMsg = document.getElementById("usedAllVotesMessage");
        if (voteBtn && usedAllMsg) {
          voteBtn.style.display = "none";
          usedAllMsg.style.display = "none";
        }
        return;
      }

      // New account -> re-run PoH gate
      currentAccount = accounts[0];
      window.currentAccount = currentAccount;
      updateAddressDisplay(currentAccount);
      connectButtonMode = "connect";
      setConnectingState(false);
      showGateOnly();
    });

    window.ethereum.on("chainChanged", async (_chainId) => {
      // Just re-check state after network changes if already connected
      if (currentAccount) {
        try {
          await ensureProviderAndContract();
          await refreshUserAndGlobalState();
        } catch (e) {
          console.warn("Could not refresh after chain change", e);
        }
      }
    });
  }

  async function autoConnectIfPossible() {
    if (!window.ethereum) return;

    try {
      const accounts = await window.ethereum.request({
        method: "eth_accounts",
      });

      if (!accounts || !accounts.length) {
        // No existing connection
        showGateOnly();
        updateAddressDisplay(null);
        return;
      }

      currentAccount = accounts[0];
      window.currentAccount = currentAccount;
      updateAddressDisplay(currentAccount);

      // Auto-run PoH gate quietly
      const pohResult = await checkPohOffchain(currentAccount);
      if (pohResult === true) {
        isPohVerified = true;
        connectButtonMode = "connected";
        setConnectingState(false);
        showAppMain();
        await ensureProviderAndContract();
        await refreshUserAndGlobalState();
      } else if (pohResult === false) {
        isPohVerified = false;
        connectButtonMode = "verify";
        setConnectingState(false);
        showGateOnly();
      } else {
        isPohVerified = null;
        connectButtonMode = "connect";
        showGateOnly();
      }
    } catch (err) {
      console.error("Auto-connect error:", err);
      showGateOnly();
      updateAddressDisplay(null);
    }
  }

  // ==========================
  //  BOOTSTRAP
  // ==========================

  window.addEventListener("load", () => {
    showGateOnly();
    wireDomEvents();
    setupWalletEventListeners();
    autoConnectIfPossible();
  });
</script>
  </body>
</html>
