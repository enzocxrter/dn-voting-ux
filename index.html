<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>DN Vote Station</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Vote on very serious topics, earn TATERZ" />

    <link rel="icon" href="assets/images/dnfavicon.ico" />

    <style>
      @font-face {
        font-family: "OverstreetBibleBold";
        src: url("assets/fonts/overstreetbiblebold.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "OverstreetBibleBold", system-ui, -apple-system,
          BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #ffffff;
        background: url("assets/images/background2.png") center center / cover
          no-repeat fixed;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .page {
        width: 100%;
        max-width: 1200px;
        padding: 20px 16px 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* HEADER / LOGO BAR */
      .header {
        width: 100%;
        height: 100px;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0;
      }

      .header-link {
        display: inline-block;
      }

      .header-logo {
        height: 120px;
        width: auto;
        transition: transform 0.3s ease;
      }

      .header-logo:hover {
        transform: scale(1.05);
      }

      /* TITLE */
      h1 {
        margin: 60px 0 40px;
        text-align: center;
        font-size: clamp(2.5rem, 5vw, 4.5rem);
        line-height: 1.1;
        text-transform: uppercase;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        color: #000000;
      }

      /* CONNECT SECTION */
      .connect-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      }

      .connect-btn {
        border: none;
        padding: 0;
        background: transparent;
        cursor: pointer;
        display: block;
        width: 260px;
        height: 80px;
        background-image: url("assets/images/connect.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .connect-btn:hover {
        background-image: url("assets/images/connecthover.png");
        transform: scale(1.15);
      }

      .connect-btn:active {
        transform: scale(0.98);
      }

      .connect-hover-text {
        margin-top: 16px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #f5f5f5;
        font-size: 2rem;
        opacity: 0;
        transform: translateY(8px);
        transition:
          opacity 0.2s ease-out,
          transform 0.2s ease-out;
        pointer-events: none;
      }

      .connect-wrapper:hover .connect-hover-text {
        opacity: 1;
        transform: translateY(0);
      }

      /* NOT VERIFIED STATE */
      .not-verified {
        margin-top: 24px;
        text-align: center;
        font-size: 1.4rem;
      }

      .verify-btn {
        margin-top: 12px;
        display: inline-block;
        width: 260px;
        height: 80px;
        background-image: url("assets/images/verifyhere.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        border: none;
        cursor: pointer;
        text-decoration: none;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .verify-btn:hover {
        background-image: url("assets/images/verifyherehover.png");
        transform: scale(1.15);
      }

      .verify-btn:active {
        transform: scale(0.98);
      }

      /* VOTING STATION */
      .voting-station {
        margin-top: 20px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #ffffff;
      }

      .voting-layout {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        justify-content: center;
      }

      .voting-content {
        flex: 1;
        min-width: 0;
      }

      .voting-title {
        font-size: clamp(2rem, 4vw, 3rem);
        text-transform: uppercase;
        margin-bottom: 16px;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
      }

      /* PoH status + rank pill */
      .poh-status {
        margin-bottom: 20px;
        font-size: 1.6rem;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      }

      .poh-status-label {
        color: #ffffff;
      }

      .poh-status-yes {
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 6px #000,
          0 0 10px #000;
      }

      .poh-rank {
        font-size: 1.6rem;
        padding: 4px 12px;
        border-radius: 999px;
        background: rgba(18, 206, 236, 0.2);
        border: 1px solid rgba(0, 255, 232, 0.7);
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 8px #000,
          0 0 12px #000;
      }

      .vote-stats {
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-size: 1.4rem;
        margin-bottom: 24px;
      }

      .vote-stat-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(0, 0, 0, 0.45);
        padding: 10px 16px;
        border-radius: 10px;
      }

      .vote-stat-label {
        text-align: left;
      }

      .vote-stat-value {
        text-align: right;
      }

      .vote-action {
        margin-top: 10px;
        font-size: 1.6rem;
      }

      .no-votes-text {
        font-size: 1.6rem;
        opacity: 0.9;
      }

      /* YES / NO basic poll UI */
      .yn-panel {
        display: flex;
        gap: 12px;
        justify-content: center;
        margin-bottom: 18px;
        flex-wrap: wrap;
      }

      .yn-card {
        width: 220px;
        background: rgba(0, 0, 0, 0.45);
        border-radius: 12px;
        padding: 14px 16px;
        text-align: center;
      }

      .yn-label {
        font-size: 1.4rem;
        text-transform: uppercase;
        opacity: 0.95;
      }

      .yn-value {
        margin-top: 6px;
        font-size: 2.4rem;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
      }

      .yn-actions {
        display: flex;
        gap: 12px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .yn-btn {
        border: none;
        cursor: pointer;
        padding: 14px 18px;
        min-width: 180px;
        border-radius: 12px;
        font-family: inherit;
        font-size: 1.4rem;
        text-transform: uppercase;
        background: rgba(0, 0, 0, 0.55);
        color: #ffffff;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
        transition: transform 0.15s ease-out, opacity 0.15s ease-out;
      }

      .yn-btn:hover {
        transform: scale(1.06);
      }

      .yn-btn:active {
        transform: scale(0.98);
      }

      /* LEADERBOARD */
      .leaderboard {
        margin-top: 40px;
        width: 100%;
        max-width: 600px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 16px;
        padding: 16px 20px 24px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.8);

        max-height: 500px;
        overflow-y: auto;
      }

      .leaderboard-title {
        font-size: 1.8rem;
        text-transform: uppercase;
        margin-bottom: 12px;
        text-align: center;
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 1.2rem;
      }

      .leaderboard-table th,
      .leaderboard-table td {
        padding: 8px 10px;
        text-align: left;
      }

      .leaderboard-table th {
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        opacity: 0.9;
      }

      .leaderboard-table tr:nth-child(even) td {
        background: rgba(255, 255, 255, 0.03);
      }

      .leaderboard-table td.rank-col {
        width: 40px;
      }

      .leaderboard-table td.title-col {
        width: 200px;
      }

      .leaderboard-table td.votes-col {
        text-align: right;
        width: 120px;
      }

      .leaderboard-row-me td {
        background: rgba(18, 206, 236, 0.18) !important;
        font-weight: 600;
      }

      @media (max-width: 600px) {
        .header {
          height: 80px;
        }

        .header-logo {
          height: 60px;
        }

        .connect-btn {
          width: 220px;
          height: 70px;
        }

        h1 {
          margin-top: 40px;
        }

        .connect-hover-text {
          font-size: 1.6rem;
        }

        .vote-stats {
          font-size: 1.2rem;
        }

        .poh-status {
          font-size: 1.4rem;
        }

        .voting-layout {
          flex-direction: column;
          align-items: center;
        }
      }

      .hidden {
        display: none !important;
      }

      /* simple feedback boxes under the vote action */
      #errorBox {
        margin-top: 12px;
        color: #ffb3b3;
        text-shadow: 0 0 6px #000;
        display: none;
      }

      #successBox {
        margin-top: 8px;
        color: #b3ffd2;
        text-shadow: 0 0 6px #000;
        display: none;
      }
    </style>
  </head>

  <body>
    <div class="page">
      <header class="header">
        <a
          href="https://www.davydonothing.com"
          target="_blank"
          rel="noopener noreferrer"
          class="header-link"
        >
          <img
            src="assets/images/dnlogo2.png"
            alt="DN Brotato logo"
            class="header-logo"
          />
        </a>
      </header>

      <h1>DN Voting Platform</h1>

      <!-- STATE 1: CONNECT (shown initially) -->
      <div class="connect-wrapper" id="connectSection">
        <button
          class="connect-btn"
          id="connectWalletButton"
          aria-label="Connect Wallet"
        ></button>

        <div class="connect-hover-text">
          <p>Connect your wallet to vote on SERIOUS topics</p>
        </div>
      </div>

      <!-- STATE 2: NOT POH VERIFIED -->
      <div class="not-verified hidden" id="notVerifiedSection">
        <p>This wallet is not PoH verified yet.</p>
        <a
          href="#"
          target="_blank"
          rel="noopener noreferrer"
          class="verify-btn"
          id="verifyLink"
          aria-label="Verify PoH"
        ></a>
      </div>

      <!-- STATE 3: VOTING STATION -->
      <div class="voting-station hidden" id="votingSection">
        <div class="voting-layout">
          <!-- RIGHT: Vote content -->
          <div class="voting-content">
            <div class="voting-title">Voting station</div>

            <div class="poh-status">
              <span class="poh-status-label">Proof of Humanity verified:</span>
              <span class="poh-status-yes" id="pohStatusYes">Yes</span>
              <span class="poh-rank hidden" id="userRankLabel"></span>
            </div>

            <!-- YES/NO COUNTERS (UX-only) -->
            <div class="yn-panel" id="ynPanel">
              <div class="yn-card">
                <div class="yn-label">Yes</div>
                <div class="yn-value" id="yesVotes">0</div>
              </div>

              <div class="yn-card">
                <div class="yn-label">No</div>
                <div class="yn-value" id="noVotes">0</div>
              </div>
            </div>

            <div class="vote-stats">
              <div class="vote-stat-row">
                <div class="vote-stat-label">Votes this round</div>
                <div class="vote-stat-value" id="totalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Your total votes</div>
                <div class="vote-stat-value" id="userTotalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Votes today</div>
                <div class="vote-stat-value" id="votesToday">0/10</div>
              </div>
            </div>

            <div class="vote-action" id="voteAction">
              <!-- Vote Yes/No buttons + "no votes" message inserted by JS -->
            </div>

            <!-- Simple feedback boxes -->
            <div id="errorBox" class="no-votes-text"></div>
            <div id="successBox" class="no-votes-text"></div>
          </div>
        </div>
      </div>

      <!-- LEADERBOARD -->
      <div class="leaderboard" id="leaderboardSection">
        <div class="leaderboard-title">Top Voters</div>
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th class="rank-col">#</th>
              <th class="title-col">Title</th>
              <th>Wallet</th>
              <th class="votes-col">Total Votes</th>
            </tr>
          </thead>
          <tbody id="leaderboardBody">
            <tr>
              <td colspan="4">No votes yet. Be the first to vote.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Ethers v6 UMD -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

    <script>
      // ==========================
      //  CONFIG / CONSTANTS
      // ==========================

      // Mainnet voting / TATERZ contract
      const CONTRACT_ADDRESS = "0xBE817fd849FbF8DBd07840F2F3a89F2D649994A3";

      // Minimal ABI for the DN voting + TATERZ contract.
      const CONTRACT_ABI = [
        "function vote(bytes signature)",
        "function totalVotesGlobal() view returns (uint256)",
        "function maxVotesPerDay() view returns (uint8)",
        "function votesLeftToday(address user) view returns (uint256)",
        "function totalVotesOf(address user) view returns (uint256)",
        "function getUserInfo(address user) view returns (uint64 dayIndex, uint8 votesToday, uint256 totalVotes, uint256 tokensClaimed, uint8 votesLeft)"
      ];

      // Linea PoH HTTP API (UX gate)
      const POH_API_BASE = "https://poh-api.linea.build/poh/v2";

      // Linea PoH signer API (on-chain verifier)
      const POH_SIGNER_API_BASE = "https://poh-signer-api.linea.build/poh/v2";

      // Where to send non-PoH users
      const POH_PORTAL_URL =
        "https://linea.build/hub/apps/sumsub-reusable-identity";

      const LINEA_CHAIN_ID = 59144n;

      // Vote 1 finished at 7,578 total votes
      // Vote 2 = totalVotesGlobal - VOTE1_FINAL_TOTAL (clamped at 0)
      const VOTE1_FINAL_TOTAL = 7578;

      // LEADERBOARD settings
      const LEADERBOARD_MAX_ENTRIES = 100;
      const LEADERBOARD_FROM_BLOCK = 0n;

      // YES/NO vote counters (UX-only, stored locally per browser)
      const YESNO_STORAGE_KEY = "dn_vote_yesno_v1";

      function readYesNoCounts() {
        try {
          const raw = localStorage.getItem(YESNO_STORAGE_KEY);
          if (!raw) return { yes: 0, no: 0 };
          const parsed = JSON.parse(raw);
          return {
            yes: Number(parsed?.yes) || 0,
            no: Number(parsed?.no) || 0
          };
        } catch {
          return { yes: 0, no: 0 };
        }
      }

      function writeYesNoCounts(counts) {
        try {
          localStorage.setItem(YESNO_STORAGE_KEY, JSON.stringify(counts));
        } catch {
          // ignore storage errors
        }
      }

      function renderYesNoCounts() {
        const counts = readYesNoCounts();
        const yesEl = $("yesVotes");
        const noEl = $("noVotes");
        if (yesEl) yesEl.textContent = counts.yes.toLocaleString();
        if (noEl) noEl.textContent = counts.no.toLocaleString();
      }

      function incrementYesNo(choice) {
        const counts = readYesNoCounts();
        if (choice === "yes") counts.yes += 1;
        if (choice === "no") counts.no += 1;
        writeYesNoCounts(counts);
        renderYesNoCounts();
      }

      // ==========================
      //  GLOBAL STATE
      // ==========================

      let provider = null;
      let signer = null;
      let contract = null;
      let currentAccount = null;
      let isPohVerified = null;

      // ==========================
      //  DOM HELPERS
      // ==========================

      function $(id) {
        return document.getElementById(id);
      }

      function showConnectSection() {
        const connectSection = $("connectSection");
        const notVerifiedSection = $("notVerifiedSection");
        const votingSection = $("votingSection");
        if (connectSection) connectSection.classList.remove("hidden");
        if (notVerifiedSection) notVerifiedSection.classList.add("hidden");
        if (votingSection) votingSection.classList.add("hidden");
      }

      function showNotVerifiedSection() {
        const connectSection = $("connectSection");
        const notVerifiedSection = $("notVerifiedSection");
        const votingSection = $("votingSection");
        if (connectSection) connectSection.classList.add("hidden");
        if (notVerifiedSection) notVerifiedSection.classList.remove("hidden");
        if (votingSection) votingSection.classList.add("hidden");
      }

      function showVotingSection() {
        const connectSection = $("connectSection");
        const notVerifiedSection = $("notVerifiedSection");
        const votingSection = $("votingSection");
        if (connectSection) connectSection.classList.add("hidden");
        if (notVerifiedSection) notVerifiedSection.classList.add("hidden");
        if (votingSection) votingSection.classList.remove("hidden");
      }

      function setError(message) {
        const el = $("errorBox");
        const successEl = $("successBox");
        if (successEl) {
          successEl.textContent = "";
          successEl.style.display = "none";
        }
        if (!el) return;
        if (!message) {
          el.textContent = "";
          el.style.display = "none";
        } else {
          el.textContent = message;
          el.style.display = "block";
        }
      }

      function setSuccess(message) {
        const el = $("successBox");
        const errorEl = $("errorBox");
        if (errorEl) {
          errorEl.textContent = "";
          errorEl.style.display = "none";
        }
        if (!el) return;
        if (!message) {
          el.textContent = "";
          el.style.display = "none";
        } else {
          el.textContent = message;
          el.style.display = "block";
        }
      }

      function setVoteButtonBusy(isBusy) {
        const yesBtn = $("voteYesButton");
        const noBtn = $("voteNoButton");
        [yesBtn, noBtn].forEach((btn) => {
          if (!btn) return;
          btn.disabled = isBusy;
          btn.style.opacity = isBusy ? "0.6" : "1";
        });
      }

      // ==========================
      //  ETH / PROVIDER HELPERS
      // ==========================

      async function ensureProviderAndContract() {
        if (!window.ethereum) {
          throw new Error("MetaMask not found");
        }
        if (!provider) {
          provider = new ethers.BrowserProvider(window.ethereum);
        }
        if (!signer) {
          signer = await provider.getSigner();
        }
        if (!contract) {
          contract = new ethers.Contract(
            CONTRACT_ADDRESS,
            CONTRACT_ABI,
            signer
          );
        }
        return { provider, signer, contract };
      }

      async function ensureOnLinea() {
        if (!window.ethereum) return false;
        if (!provider) {
          provider = new ethers.BrowserProvider(window.ethereum);
        }
        const net = await provider.getNetwork();
        return net.chainId === LINEA_CHAIN_ID;
      }

      // ==========================
      //  PROOF OF HUMANITY (HTTP)
      // ==========================

      async function checkPohOffchain(address) {
        try {
          console.log("Checking PoH via HTTP for", address);
          const res = await fetch(`${POH_API_BASE}/${address}`);
          if (!res.ok) {
            throw new Error(`PoH HTTP ${res.status}`);
          }
          const text = (await res.text()).trim(); // "true" or "false"
          const isHuman = text === "true";
          console.log("PoH API result:", isHuman);
          return isHuman;
        } catch (err) {
          console.error("PoH API error:", err);
          return null;
        }
      }

      // ==========================
      //  LEADERBOARD (LOGS)
      // ==========================

      // Helper: fetch logs in chunks to avoid RPC "more than 10000 results" error
      async function fetchAllLogs(provider, address, fromBlock, toBlock) {
        let startBlock =
          typeof fromBlock === "bigint" ? fromBlock : BigInt(fromBlock);
        let endBlock =
          typeof toBlock === "bigint" ? toBlock : BigInt(toBlock);

        const allLogs = [];

        async function fetchRange(start, end) {
          if (end < start) return;
          try {
            const partial = await provider.getLogs({
              address,
              fromBlock: start,
              toBlock: end
            });
            allLogs.push(...partial);
          } catch (err) {
            const msg = (err?.message || "").toLowerCase();
            if (msg.includes("more than 10000 results")) {
              const span = end - start;
              if (span <= 0n) {
                console.error(
                  "Cannot split block range further but still too many results:",
                  start.toString(),
                  end.toString()
                );
                return;
              }
              const mid = start + (span >> 1n);
              await fetchRange(start, mid);
              await fetchRange(mid + 1n, end);
            } else {
              console.error(
                "Error fetching logs for range",
                start.toString(),
                end.toString(),
                err
              );
            }
          }
        }

        await fetchRange(startBlock, endBlock);
        return allLogs;
      }

      // ----- RANK TITLES -----
      function getRankTitle(rank) {
        switch (rank) {
          case 1:
            return "Follicle Liquidatooor";
          case 2:
            return "Hairline Rugpuller";
          case 3:
            return "The Buzzcut Butcher";
          case 4:
            return "Scalp Sniper";
          case 5:
            return "Chrome Dome Degen";
          case 6:
            return "The Clippersmith";
          case 7:
            return "The Bald Bringer";
          case 8:
            return "Harbinger of Hair Loss";
          case 9:
            return "The Hairline Eradicator";
          case 10:
            return "Supreme Scalp Sacrificer";
          case 11:
            return "The No-Hair Enabler";
          case 12:
            return "Clipper Kingpin";
          case 13:
            return "Follicle Doom Dealer";
          case 14:
            return "Clean Cut Kingmaker";
          case 15:
            return "Final Strand Supervisor";
          case 16:
            return "Commander of Clippers";
          case 17:
            return "Buzzcut Broker";
          case 18:
            return "Final Shave Boss";
          case 19:
            return "DN Bladesmith";
          case 20:
            return "Clean Shave Sgt";
          default:
            return "Bald Enforcer";
        }
      }

      async function loadLeaderboard() {
        try {
          const { provider } = await ensureProviderAndContract();

          let latestBlock = await provider.getBlockNumber();
          if (typeof latestBlock === "number") {
            latestBlock = BigInt(latestBlock);
          }

          const logs = await fetchAllLogs(
            provider,
            CONTRACT_ADDRESS,
            LEADERBOARD_FROM_BLOCK,
            latestBlock
          );

          const counts = new Map();

          for (const log of logs) {
            if (!log.topics || log.topics.length < 2) continue;

            try {
              const topic = log.topics[1];
              if (!topic || topic.length !== 66) continue;
              const addr = ethers.getAddress("0x" + topic.slice(26));
              const prev = counts.get(addr) || 0;
              counts.set(addr, prev + 1);
            } catch (e) {
              // ignore logs that don't decode cleanly to an address
            }
          }

          const rows = Array.from(counts.entries())
            .map(([wallet, votes]) => ({ wallet, votes }))
            .sort((a, b) => b.votes - a.votes)
            .slice(0, LEADERBOARD_MAX_ENTRIES);

          const tbody = $("leaderboardBody");
          if (!tbody) return;

          tbody.innerHTML = "";

          if (rows.length === 0) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 4;
            td.textContent = "No votes yet. Be the first to vote.";
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
          }

          const me = currentAccount ? currentAccount.toLowerCase() : null;

          rows.forEach((row, index) => {
            const tr = document.createElement("tr");
            if (me && row.wallet.toLowerCase() === me) {
              tr.classList.add("leaderboard-row-me");
            }

            const rankTd = document.createElement("td");
            rankTd.className = "rank-col";
            rankTd.textContent = (index + 1).toString();

            const titleTd = document.createElement("td");
            titleTd.className = "title-col";
            titleTd.textContent = getRankTitle(index + 1);

            const walletTd = document.createElement("td");
            walletTd.textContent =
              row.wallet.slice(0, 6) + "..." + row.wallet.slice(-4);

            const votesTd = document.createElement("td");
            votesTd.className = "votes-col";
            votesTd.textContent = row.votes.toLocaleString();

            tr.appendChild(rankTd);
            tr.appendChild(titleTd);
            tr.appendChild(walletTd);
            tr.appendChild(votesTd);
            tbody.appendChild(tr);
          });
        } catch (err) {
          console.error("Error loading leaderboard:", err);
          // If it fails, we just leave the existing table contents.
        }
      }

      // ==========================
      //  STATE REFRESH (ON-CHAIN)
      // ==========================

      async function refreshUserAndGlobalState() {
        if (!currentAccount) return;

        try {
          const { contract } = await ensureProviderAndContract();

          let totalVotesGlobal = 0;
          let maxVotesPerDay = 10;
          let votesLeft = null;
          let userTotalVotes = null;
          let votesToday = null;

          // Global totals
          try {
            const totalBn = await contract.totalVotesGlobal();
            totalVotesGlobal = Number(totalBn);
          } catch (e) {
            console.warn("totalVotesGlobal read failed", e);
          }

          try {
            const maxBn = await contract.maxVotesPerDay();
            maxVotesPerDay = Number(maxBn);
          } catch (e) {
            console.warn("maxVotesPerDay read failed, using default 10", e);
          }

          // Per-user
          try {
            const info = await contract.getUserInfo(currentAccount);
            // [dayIndex, votesToday, totalVotes, tokensClaimed, votesLeft]
            votesToday = Number(info[1]);
            userTotalVotes = Number(info[2]);
            votesLeft = Number(info[4]);
          } catch (e) {
            console.warn("getUserInfo read failed, falling back", e);
            try {
              const leftBn = await contract.votesLeftToday(currentAccount);
              votesLeft = Number(leftBn);
            } catch (e2) {
              console.warn("votesLeftToday read failed", e2);
            }
            try {
              const totalBn = await contract.totalVotesOf(currentAccount);
              userTotalVotes = Number(totalBn);
            } catch (e3) {
              console.warn("totalVotesOf read failed", e3);
            }
          }

          // ===== Vote 2 logic (kept for existing "Votes this round" display) =====
          const totalVotesRound = Math.max(
            0,
            totalVotesGlobal != null ? totalVotesGlobal - VOTE1_FINAL_TOTAL : 0
          );

          // Update stats UI
          const totalVotesEl = $("totalVotes");
          if (totalVotesEl) {
            totalVotesEl.textContent = totalVotesRound.toLocaleString();
          }

          const userTotalVotesEl = $("userTotalVotes");
          if (userTotalVotesEl) {
            userTotalVotesEl.textContent =
              userTotalVotes != null
                ? userTotalVotes.toLocaleString()
                : "-";
          }

          const votesTodayEl = $("votesToday");
          if (votesTodayEl) {
            if (votesLeft != null && maxVotesPerDay != null) {
              const used = Math.max(0, maxVotesPerDay - Number(votesLeft));
              votesTodayEl.textContent = `${used}/${maxVotesPerDay}`;
            } else if (votesToday != null && maxVotesPerDay != null) {
              votesTodayEl.textContent = `${votesToday}/${maxVotesPerDay}`;
            } else {
              votesTodayEl.textContent = `0/${maxVotesPerDay}`;
            }
          }

          // Show/hide vote buttons *only* if we know they have 0 left.
          const yesBtn = $("voteYesButton");
          const noBtn = $("voteNoButton");
          const usedMsg = $("usedAllVotesMessage");

          if (usedMsg) {
            if (votesLeft === 0) {
              if (yesBtn) yesBtn.classList.add("hidden");
              if (noBtn) noBtn.classList.add("hidden");
              usedMsg.classList.remove("hidden");
              usedMsg.textContent =
                "You’ve used all votes for now. Come back later.";
            } else {
              if (yesBtn) yesBtn.classList.remove("hidden");
              if (noBtn) noBtn.classList.remove("hidden");
              usedMsg.classList.add("hidden");
            }
          }

          // Update leaderboard from logs (all-time)
          await loadLeaderboard();
        } catch (err) {
          console.error("Error reading user/global state:", err);
          const yesBtn = $("voteYesButton");
          const noBtn = $("voteNoButton");
          const usedMsg = $("usedAllVotesMessage");
          if (yesBtn) yesBtn.classList.remove("hidden");
          if (noBtn) noBtn.classList.remove("hidden");
          if (usedMsg) usedMsg.classList.add("hidden");
        }
      }

      // ==========================
      //  CONNECT FLOW
      // ==========================

      async function handleConnectClick() {
        setError("");
        setSuccess("");

        if (!window.ethereum) {
          setError("MetaMask not found. Please install it to continue.");
          return;
        }

        try {
          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts"
          });

          if (!accounts || !accounts.length) {
            setError("No wallet selected.");
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount; // for debugging

          // HTTP PoH gate first
          const pohResult = await checkPohOffchain(currentAccount);

          if (pohResult === true) {
            isPohVerified = true;
            showVotingSection();
            $("pohStatusYes").textContent = "Yes";

            // Init contract + state
            await ensureProviderAndContract();
            await refreshUserAndGlobalState();
          } else if (pohResult === false) {
            isPohVerified = false;
            showNotVerifiedSection();
            const verifyLink = $("verifyLink");
            if (verifyLink) {
              verifyLink.href = POH_PORTAL_URL;
            }
            setError(
              "This wallet is not Proof-of-Humanity verified. Use the Verify link to complete PoH."
            );
          } else {
            isPohVerified = null;
            showConnectSection();
            setError(
              "Could not check Proof of Humanity. Please try again in a moment."
            );
          }
        } catch (err) {
          console.error("Connect/init error:", err);
          setError("Failed to connect wallet. Check console for details.");
        }
      }

      // ==========================
      //  VOTE (ON-CHAIN POH)
      // ==========================

      async function onVoteClick(choice) {
        setError("");
        setSuccess("");

        try {
          if (!window.ethereum) {
            setError("MetaMask not found.");
            return;
          }
          if (!currentAccount) {
            setError("Connect your wallet first.");
            return;
          }

          const { provider, contract } = await ensureProviderAndContract();

          const onLinea = await ensureOnLinea();
          if (!onLinea) {
            setError("Please switch your wallet network to Linea.");
            return;
          }

          // Soft UX guard: if HTTP PoH said "false", block.
          if (isPohVerified === false) {
            setError(
              "This wallet is not PoH verified via Linea. Complete PoH first."
            );
            return;
          }

          setVoteButtonBusy(true);

          // Get PoH signature from Linea signer API
          const sigRes = await fetch(
            `${POH_SIGNER_API_BASE}/${currentAccount}`
          );
          if (!sigRes.ok) {
            throw new Error(`PoH signer HTTP ${sigRes.status}`);
          }
          const rawSig = (await sigRes.text()).trim();
          if (!rawSig || rawSig === "0x") {
            throw new Error(
              "Empty PoH signature from Linea signer. Wallet may not be on-chain PoH verified yet."
            );
          }
          if (!rawSig.startsWith("0x")) {
            throw new Error("Invalid PoH signature format from Linea signer.");
          }
          const pohSignature = rawSig;

          // Send vote transaction (same backend call for Yes/No)
          const tx = await contract.vote(pohSignature);
          await tx.wait();

          // UX-only yes/no counter increment (local)
          if (choice === "yes" || choice === "no") {
            incrementYesNo(choice);
          }

          setSuccess(
            "Vote successful! Your TATERZ claim + vote has been recorded."
          );
          await refreshUserAndGlobalState();
        } catch (err) {
          console.error("Vote tx error:", err);

          const rawMsg =
            err?.error?.message ||
            err?.data?.message ||
            err?.reason ||
            err?.message ||
            String(err ?? "");
          const lower = rawMsg.toLowerCase();

          if (
            err?.code === "ACTION_REJECTED" ||
            lower.includes("user rejected")
          ) {
            setError("Transaction rejected in wallet.");
          } else if (
            lower.includes("notpohverified") ||
            lower.includes("not poh verified")
          ) {
            setError(
              "This wallet is not PoH-verified according to Linea's on-chain verifier. Complete PoH with this wallet."
            );
          } else if (lower.includes("daily") && lower.includes("limit")) {
            setError("You’ve used all votes for now. Come back later.");
          } else if (
            lower.includes("not enough taterz") ||
            lower.includes("insufficient taterz")
          ) {
            setError(
              "Voting contract does not have enough TATERZ to pay rewards. Please contact the team."
            );
          } else if (
            lower.includes("ecdsa: invalid signature length") ||
            lower.includes("invalid signature")
          ) {
            setError(
              "Linea PoH signature was invalid. If you recently verified, give it a few minutes and try again. Otherwise re-do PoH with this wallet."
            );
          } else if (lower.includes("signer http")) {
            setError(
              "Could not fetch PoH signature from Linea signer API. Please try again shortly."
            );
          } else if (lower.includes("empty poh signature")) {
            setError(
              "Linea signer returned an empty PoH signature. This usually means the wallet is not registered yet. Re-do PoH with this wallet."
            );
          } else {
            setError("Vote transaction failed. Check console for details.");
          }
        } finally {
          setVoteButtonBusy(false);
        }
      }

      // ==========================
      //  WALLET EVENTS & AUTO-CONNECT
      // ==========================

      function setupWalletEventListeners() {
        if (!window.ethereum) return;

        window.ethereum.on("accountsChanged", (accounts) => {
          setError("");
          setSuccess("");

          if (!accounts || !accounts.length) {
            currentAccount = null;
            provider = null;
            signer = null;
            contract = null;
            isPohVerified = null;
            showConnectSection();
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount;
          // Re-run gate for the new account
          showConnectSection();
        });

        window.ethereum.on("chainChanged", async () => {
          if (currentAccount && isPohVerified) {
            try {
              await refreshUserAndGlobalState();
            } catch (e) {
              console.warn("Could not refresh after chain change", e);
            }
          }
        });
      }

      async function autoConnectIfPossible() {
        if (!window.ethereum) {
          showConnectSection();
          return;
        }

        try {
          const accounts = await window.ethereum.request({
            method: "eth_accounts"
          });

          if (!accounts || !accounts.length) {
            showConnectSection();
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount;

          // Auto-run PoH gate quietly
          const pohResult = await checkPohOffchain(currentAccount);
          if (pohResult === true) {
            isPohVerified = true;
            showVotingSection();
            $("pohStatusYes").textContent = "Yes";
            await ensureProviderAndContract();
            await refreshUserAndGlobalState();
          } else if (pohResult === false) {
            isPohVerified = false;
            showNotVerifiedSection();
            const verifyLink = $("verifyLink");
            if (verifyLink) {
              verifyLink.href = POH_PORTAL_URL;
            }
          } else {
            isPohVerified = null;
            showConnectSection();
          }
        } catch (err) {
          console.error("Auto-connect error:", err);
          showConnectSection();
        }
      }

      // ==========================
      //  BOOTSTRAP
      // ==========================

      window.addEventListener("load", () => {
        // Insert Vote Yes/No buttons + "used all" text
        const voteAction = $("voteAction");
        if (voteAction) {
          const actions = document.createElement("div");
          actions.className = "yn-actions";

          const yesBtn = document.createElement("button");
          yesBtn.id = "voteYesButton";
          yesBtn.className = "yn-btn";
          yesBtn.type = "button";
          yesBtn.textContent = "Vote Yes";
          yesBtn.setAttribute("aria-label", "Vote Yes");
          yesBtn.addEventListener("click", () => onVoteClick("yes"));

          const noBtn = document.createElement("button");
          noBtn.id = "voteNoButton";
          noBtn.className = "yn-btn";
          noBtn.type = "button";
          noBtn.textContent = "Vote No";
          noBtn.setAttribute("aria-label", "Vote No");
          noBtn.addEventListener("click", () => onVoteClick("no"));

          actions.appendChild(yesBtn);
          actions.appendChild(noBtn);
          voteAction.appendChild(actions);

          const usedMsg = document.createElement("div");
          usedMsg.id = "usedAllVotesMessage";
          usedMsg.className = "no-votes-text hidden";
          usedMsg.textContent =
            "You’ve used all votes for now. Come back later.";
          voteAction.appendChild(usedMsg);
        }

        // Render local yes/no counters on load
        renderYesNoCounts();

        const connectBtn = $("connectWalletButton");
        if (connectBtn) {
          connectBtn.addEventListener("click", handleConnectClick);
        }

        showConnectSection();
        setupWalletEventListeners();
        autoConnectIfPossible();
      });
    </script>
  </body>
</html>
