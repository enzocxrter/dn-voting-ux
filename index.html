<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>DN Vote Station</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Vote on very serious topics, earn TATERZ" />

    <link rel="icon" href="assets/images/dnfavicon.ico" />

    <style>
      @font-face {
        font-family: "OverstreetBibleBold";
        src: url("assets/fonts/overstreetbiblebold.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "OverstreetBibleBold", system-ui, -apple-system,
          BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #ffffff;
        background: url("assets/images/background2.png") center center / cover
          no-repeat fixed;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .page {
        width: 100%;
        max-width: 1200px;
        padding: 20px 16px 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* HEADER / LOGO BAR */
      .header {
        width: 100%;
        height: 100px;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0;
      }

      .header-link {
        display: inline-block;
      }

      .header-logo {
        height: 120px;
        width: auto;
        transition: transform 0.3s ease;
      }

      .header-logo:hover {
        transform: scale(1.05);
      }

      /* TITLE */
      h1 {
        margin: 60px 0 40px;
        text-align: center;
        font-size: clamp(2.5rem, 5vw, 4.5rem);
        line-height: 1.1;
        text-transform: uppercase;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        color: #000000;
      }

      /* CONNECT SECTION */
      .connect-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      }

      .connect-btn {
        border: none;
        padding: 0;
        background: transparent;
        cursor: pointer;
        display: block;
        width: 260px;
        height: 80px;
        background-image: url("assets/images/connect.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .connect-btn:hover {
        background-image: url("assets/images/connecthover.png");
        transform: scale(1.15);
      }

      .connect-btn:active {
        transform: scale(0.98);
      }

      .connect-hover-text {
        margin-top: 16px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #f5f5f5;
        font-size: 2rem;
        opacity: 0;
        transform: translateY(8px);
        transition:
          opacity 0.2s ease-out,
          transform 0.2s ease-out;
        pointer-events: none;
      }

      .connect-wrapper:hover .connect-hover-text {
        opacity: 1;
        transform: translateY(0);
      }

      /* NOT VERIFIED STATE */
      .not-verified {
        margin-top: 24px;
        text-align: center;
        font-size: 1.4rem;
      }

      .verify-btn {
        margin-top: 12px;
        display: inline-block;
        width: 260px;
        height: 80px;
        background-image: url("assets/images/verifyhere.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        border: none;
        cursor: pointer;
        text-decoration: none;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .verify-btn:hover {
        background-image: url("assets/images/verifyherehover.png");
        transform: scale(1.15);
      }

      .verify-btn:active {
        transform: scale(0.98);
      }

      /* VOTING STATION */
      .voting-station {
        margin-top: 20px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #ffffff;
      }

      .voting-layout {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        justify-content: center;
      }

      .voting-content {
        flex: 1;
        min-width: 0;
      }

      .voting-title {
        font-size: clamp(2rem, 4vw, 3rem);
        text-transform: uppercase;
        margin-bottom: 16px;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
      }

      /* PoH status + rank pill */
      .poh-status {
        margin-bottom: 20px;
        font-size: 1.6rem;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      }

      .poh-status-label {
        color: #ffffff;
      }

      .poh-status-yes {
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 6px #000,
          0 0 10px #000;
      }

      .poh-rank {
        font-size: 1.6rem;
        padding: 4px 12px;
        border-radius: 999px;
        background: rgba(18, 206, 236, 0.2);
        border: 1px solid rgba(0, 255, 232, 0.7);
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 8px #000,
          0 0 12px #000;
      }

      .vote-stats {
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-size: 1.4rem;
        margin-bottom: 24px;
      }

      .vote-stat-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(0, 0, 0, 0.45);
        padding: 10px 16px;
        border-radius: 10px;
      }

      .vote-stat-label {
        text-align: left;
      }

      .vote-stat-value {
        text-align: right;
      }

      .vote-action {
        margin-top: 10px;
        font-size: 1.6rem;
      }

      .vote-btn {
        border: none;
        padding: 0;
        background: transparent;
        cursor: pointer;
        display: inline-block;
        width: 220px;
        height: 70px;
        background-image: url("assets/images/vote.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .vote-btn:hover {
        background-image: url("assets/images/votehover.png");
        transform: scale(1.15);
      }

      .vote-btn:active {
        transform: scale(0.98);
      }

      .no-votes-text {
        font-size: 1.6rem;
        opacity: 0.9;
      }

      /* LEFT SIDE: VOTE THERMOMETER */
      .thermo-wrapper {
        width: 200px;
        padding: 16px 12px 20px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 20px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
        text-align: center;
      }

      .thermo-title {
        font-size: 1.4rem;
        text-transform: uppercase;
        margin-bottom: 12px;
      }

      .thermo-body {
        position: relative;
        width: 90px;
        height: 460px;
        margin: 0 auto 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .thermo-column {
        position: relative;
        width: 36px;
        height: 340px;
        margin-top: 6px;
        border-radius: 999px;
        border: 4px solid rgba(255, 255, 255, 0.9);
        overflow: hidden;
        background: linear-gradient(
          to top,
          rgba(255, 255, 255, 0.12),
          rgba(255, 255, 255, 0.25)
        );
      }

      .thermo-mercury {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 0%;
        background: linear-gradient(to top, #12ceec, #00ffe8);
        box-shadow: 0 0 12px rgba(0, 255, 232, 0.8);
        transition: height 0.6s ease-out;
      }

      .thermo-bulb {
        width: 56px;
        height: 56px;
        border-radius: 999px;
        border: 4px solid rgba(255, 255, 255, 0.95);
        background: radial-gradient(circle at 30% 30%, #00ffe8, #12ceec);
        box-shadow: 0 0 18px rgba(0, 255, 232, 0.7);
        margin-top: -6px;
      }

      .thermo-face {
        position: absolute;
        left: 50%;
        width: 78px;
        height: 78px;
        border-radius: 50%;
        transform: translateX(-50%);
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.9);
        bottom: 20px;
        transition: bottom 0.6s ease-out;
        z-index: 2;
      }

      .thermo-face img {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        object-fit: contain;
      }

      .thermo-face-goal {
        position: absolute;
        left: 50%;
        width: 78px;
        height: 78px;
        border-radius: 50%;
        transform: translateX(-50%);
        top: -6px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.9);
        z-index: 2;
      }

      .thermo-face-goal img {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        object-fit: contain;
      }

      .thermo-labels {
        font-size: 1.05rem;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      #thermoCount {
        font-size: 1.3rem;
      }

      #thermoPercent {
        font-size: 1rem;
        opacity: 0.9;
      }

      .thermo-target {
        font-size: 0.9rem;
        opacity: 0.7;
      }

      /* LEADERBOARD */
      .leaderboard {
        margin-top: 40px;
        width: 100%;
        max-width: 600px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 16px;
        padding: 16px 20px 24px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.8);

        max-height: 500px;
        overflow-y: auto;
      }

      .leaderboard-title {
        font-size: 1.8rem;
        text-transform: uppercase;
        margin-bottom: 12px;
        text-align: center;
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 1.2rem;
      }

      .leaderboard-table th,
      .leaderboard-table td {
        padding: 8px 10px;
        text-align: left;
      }

      .leaderboard-table th {
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        opacity: 0.9;
      }

      .leaderboard-table tr:nth-child(even) td {
        background: rgba(255, 255, 255, 0.03);
      }

      .leaderboard-table td.rank-col {
        width: 40px;
      }

      .leaderboard-table td.title-col {
        width: 200px;
      }

      .leaderboard-table td.votes-col {
        text-align: right;
        width: 120px;
      }

      .leaderboard-row-me td {
        background: rgba(18, 206, 236, 0.18) !important;
        font-weight: 600;
      }

      @media (max-width: 600px) {
        .header {
          height: 80px;
        }

        .header-logo {
          height: 60px;
        }

        .connect-btn {
          width: 220px;
          height: 70px;
        }

        h1 {
          margin-top: 40px;
        }

        .connect-hover-text {
          font-size: 1.6rem;
        }

        .vote-stats {
          font-size: 1.2rem;
        }

        .vote-btn,
        .no-votes-text {
          font-size: 1.4rem;
        }

        .poh-status {
          font-size: 1.4rem;
        }

        .voting-layout {
          flex-direction: column;
          align-items: center;
        }

        .thermo-wrapper {
          width: 220px;
        }
      }

      .hidden {
        display: none !important;
      }

      /* simple feedback boxes under the vote action */
      #errorBox {
        margin-top: 12px;
        color: #ffb3b3;
        text-shadow: 0 0 6px #000;
        display: none;
      }

      #successBox {
        margin-top: 8px;
        color: #b3ffd2;
        text-shadow: 0 0 6px #000;
        display: none;
      }
    </style>
  </head>

  <body>
    <div class="page">
      <header class="header">
        <a
          href="https://www.davydonothing.com"
          target="_blank"
          rel="noopener noreferrer"
          class="header-link"
        >
          <img
            src="assets/images/dnlogo2.png"
            alt="DN Brotato logo"
            class="header-logo"
          />
        </a>
      </header>

      <h1>DN Voting Platform</h1>

      <!-- STATE 1: CONNECT (shown initially) -->
      <div class="connect-wrapper" id="connectSection">
        <button
          class="connect-btn"
          id="connectWalletButton"
          aria-label="Connect Wallet"
        ></button>

        <div class="connect-hover-text">
          <p>Connect your wallet to vote on SERIOUS topics</p>
        </div>
      </div>

      <!-- STATE 2: NOT POH VERIFIED -->
      <div class="not-verified hidden" id="notVerifiedSection">
        <p>This wallet is not PoH verified yet.</p>
        <a
          href="#"
          target="_blank"
          rel="noopener noreferrer"
          class="verify-btn"
          id="verifyLink"
          aria-label="Verify PoH"
        ></a>
      </div>

      <!-- STATE 3: VOTING STATION -->
      <div class="voting-station hidden" id="votingSection">
        <div class="voting-layout">
          <!-- LEFT: Vote Thermometer -->
          <div class="thermo-wrapper">
            <div class="thermo-title">Vote Heat</div>

            <div class="thermo-body">
              <div class="thermo-column">
                <div class="thermo-mercury" id="thermoMercury"></div>
              </div>
              <div class="thermo-bulb"></div>

              <!-- TOP: GOAL FACE (Joe with hair) -->
              <div class="thermo-face-goal">
                <img src="assets/images/joehair.png" alt="Joe hair" />
              </div>

              <!-- BOTTOM: MOVING FACE (bald Joe) -->
              <div class="thermo-face" id="thermoFace">
                <img src="assets/images/joe.png" alt="Joe" />
              </div>
            </div>

            <div class="thermo-labels">
              <div id="thermoCount">0</div>
              <div id="thermoPercent">0% to target</div>
              <div class="thermo-target" id="thermoTarget">
                Target: 20,000 votes
              </div>
            </div>
          </div>

          <!-- RIGHT: Vote content -->
          <div class="voting-content">
            <div class="voting-title">Voting station</div>

            <div class="poh-status">
              <span class="poh-status-label">Proof of Humanity verified:</span>
              <span class="poh-status-yes" id="pohStatusYes">Yes</span>
              <span class="poh-rank hidden" id="userRankLabel"></span>
            </div>

            <div class="vote-stats">
              <div class="vote-stat-row">
                <div class="vote-stat-label">Votes this round</div>
                <div class="vote-stat-value" id="totalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Your total votes</div>
                <div class="vote-stat-value" id="userTotalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Votes today</div>
                <div class="vote-stat-value" id="votesToday">0/10</div>
              </div>
            </div>

            <div class="vote-action" id="voteAction">
              <!-- Vote button + "no votes" message inserted by JS -->
            </div>

            <!-- Simple feedback boxes -->
            <div id="errorBox" class="no-votes-text"></div>
            <div id="successBox" class="no-votes-text"></div>
          </div>
        </div>
      </div>

      <!-- LEADERBOARD -->
      <div class="leaderboard" id="leaderboardSection">
        <div class="leaderboard-title">Top Voters</div>
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th class="rank-col">#</th>
              <th class="title-col">Title</th>
              <th>Wallet</th>
              <th class="votes-col">Total Votes</th>
            </tr>
          </thead>
          <tbody id="leaderboardBody">
            <tr>
              <td colspan="4">No votes yet. Be the first to vote.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <!-- Ethers v6 UMD -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

    <script>
      // ==========================
      //  CONFIG / CONSTANTS
      // ==========================

      // Mainnet voting / TATERZ contract
      const CONTRACT_ADDRESS = "0xBE817fd849FbF8DBd07840F2F3a89F2D649994A3";

      // Minimal ABI for the DN voting + TATERZ contract.
      // Only the functions we actually call.
      const CONTRACT_ABI = [
        "function vote(bytes signature)",
        "function totalVotesGlobal() view returns (uint256)",

        // Optional helpers (we wrap in try/catch)
        "function maxVotesPerDay() view returns (uint8)",
        "function votesLeftToday(address user) view returns (uint256)",
        "function totalVotesOf(address user) view returns (uint256)",
        "function getUserInfo(address user) view returns (uint64 dayIndex, uint8 votesToday, uint256 totalVotes, uint256 tokensClaimed, uint8 votesLeft)",
        "function targetVotes() view returns (uint256)"
      ];

      // Linea PoH HTTP API (UX gate)
      const POH_API_BASE = "https://poh-api.linea.build/poh/v2";

      // Linea PoH signer API (on-chain verifier)
      const POH_SIGNER_API_BASE = "https://poh-signer-api.linea.build/poh/v2";

      // Where to send non-PoH users
      const POH_PORTAL_URL =
        "https://linea.build/hub/apps/sumsub-reusable-identity";

      const LINEA_CHAIN_ID = 59144n;
      const DEFAULT_TARGET_VOTES = 20000;

      // Vote 1 finished at 7,578 total votes
      // Vote 2 = totalVotesGlobal - VOTE1_FINAL_TOTAL (clamped at 0)
      const VOTE1_FINAL_TOTAL = 7578;

      // LEADERBOARD settings
      const LEADERBOARD_MAX_ENTRIES = 100;
      // If you know the deploy block for the contract, set it here instead of 0n for speed.
      const LEADERBOARD_FROM_BLOCK = 0n;

      // ==========================
      //  GLOBAL STATE
      // ==========================

      let provider = null;
      let signer = null;
      let contract = null;
      let currentAccount = null;
      let isPohVerified = null;

      // ==========================
      //  DOM HELPERS
      // ==========================

      function $(id) {
        return document.getElementById(id);
      }

      function showConnectSection() {
        const connectSection = $("connectSection");
        const notVerifiedSection = $("notVerifiedSection");
        const votingSection = $("votingSection");
        if (connectSection) connectSection.classList.remove("hidden");
        if (notVerifiedSection) notVerifiedSection.classList.add("hidden");
        if (votingSection) votingSection.classList.add("hidden");
      }

      function showNotVerifiedSection() {
        const connectSection = $("connectSection");
        const notVerifiedSection = $("notVerifiedSection");
        const votingSection = $("votingSection");
        if (connectSection) connectSection.classList.add("hidden");
        if (notVerifiedSection) notVerifiedSection.classList.remove("hidden");
        if (votingSection) votingSection.classList.add("hidden");
      }

      function showVotingSection() {
        const connectSection = $("connectSection");
        const notVerifiedSection = $("notVerifiedSection");
        const votingSection = $("votingSection");
        if (connectSection) connectSection.classList.add("hidden");
        if (notVerifiedSection) notVerifiedSection.classList.add("hidden");
        if (votingSection) votingSection.classList.remove("hidden");
      }

      function setError(message) {
        const el = $("errorBox");
        const successEl = $("successBox");
        if (successEl) {
          successEl.textContent = "";
          successEl.style.display = "none";
        }
        if (!el) return;
        if (!message) {
          el.textContent = "";
          el.style.display = "none";
        } else {
          el.textContent = message;
          el.style.display = "block";
        }
      }

      function setSuccess(message) {
        const el = $("successBox");
        const errorEl = $("errorBox");
        if (errorEl) {
          errorEl.textContent = "";
          errorEl.style.display = "none";
        }
        if (!el) return;
        if (!message) {
          el.textContent = "";
          el.style.display = "none";
        } else {
          el.textContent = message;
          el.style.display = "block";
        }
      }

      function setVoteButtonBusy(isBusy) {
        const btn = $("voteButton");
        if (!btn) return;
        btn.disabled = isBusy;
        btn.style.opacity = isBusy ? "0.6" : "1";
      }

      function updateThermometer(totalVotes, targetVotes) {
        const countEl = $("thermoCount");
        const percentEl = $("thermoPercent");
        const targetEl = $("thermoTarget");
        const mercuryEl = $("thermoMercury");
        const faceEl = $("thermoFace");

        const total = typeof totalVotes === "number" ? totalVotes : 0;
        const target =
          typeof targetVotes === "number" && targetVotes > 0
            ? targetVotes
            : DEFAULT_TARGET_VOTES;

        const pct = target > 0 ? Math.min(100, (total * 100) / target) : 0;

        if (countEl) {
          countEl.textContent = total.toLocaleString();
        }
        if (percentEl) {
          percentEl.textContent = `${pct.toFixed(1)}% to target`;
        }
        if (targetEl) {
          targetEl.textContent = `Target: ${target.toLocaleString()} votes`;
        }
        if (mercuryEl) {
          mercuryEl.style.height = `${pct.toFixed(1)}%`;
        }
        if (faceEl) {
          // Tune these to align Joe with the mercury visually
          const baseBottom = 90; // px
          const maxExtra = 260; // px
          const extra = (pct / 100) * maxExtra;
          faceEl.style.bottom = `${baseBottom + extra}px`;
        }
      }

      // ==========================
      //  ETH / PROVIDER HELPERS
      // ==========================

      async function ensureProviderAndContract() {
        if (!window.ethereum) {
          throw new Error("MetaMask not found");
        }
        if (!provider) {
          provider = new ethers.BrowserProvider(window.ethereum);
        }
        if (!signer) {
          signer = await provider.getSigner();
        }
        if (!contract) {
          contract = new ethers.Contract(
            CONTRACT_ADDRESS,
            CONTRACT_ABI,
            signer
          );
        }
        return { provider, signer, contract };
      }

      async function ensureOnLinea() {
        if (!window.ethereum) return false;
        if (!provider) {
          provider = new ethers.BrowserProvider(window.ethereum);
        }
        const net = await provider.getNetwork();
        return net.chainId === LINEA_CHAIN_ID;
      }

      // ==========================
      //  PROOF OF HUMANITY (HTTP)
      // ==========================

      async function checkPohOffchain(address) {
        try {
          console.log("Checking PoH via HTTP for", address);
          const res = await fetch(`${POH_API_BASE}/${address}`);
          if (!res.ok) {
            throw new Error(`PoH HTTP ${res.status}`);
          }
          const text = (await res.text()).trim(); // "true" or "false"
          const isHuman = text === "true";
          console.log("PoH API result:", isHuman);
          return isHuman;
        } catch (err) {
          console.error("PoH API error:", err);
          return null;
        }
      }

      // ==========================
      //  LEADERBOARD (LOGS)
      // ==========================

      // ----- RANK TITLES -----
      function getRankTitle(rank) {
        switch (rank) {
          case 1:
            return "Follicle Liquidatooor";
          case 2:
            return "Hairline Rugpuller";
          case 3:
            return "The Buzzcut Butcher";
          case 4:
            return "Scalp Sniper";
          case 5:
            return "Chrome Dome Degen";
          case 6:
            return "The Clippersmith";
          case 7:
            return "The Bald Bringer";
          case 8:
            return "Harbinger of Hair Loss";
          case 9:
            return "The Hairline Eradicator";
          case 10:
            return "Supreme Scalp Sacrificer";
          case 11:
            return "The No-Hair Enabler";
          case 12:
            return "Clipper Kingpin";
          case 13:
            return "Follicle Doom Dealer";
          case 14:
            return "Clean Cut Kingmaker";
          case 15:
            return "Final Strand Supervisor";
          case 16:
            return "Commander of Clippers";
          case 17:
            return "Buzzcut Broker";
          case 18:
            return "Final Shave Boss";
          case 19:
            return "DN Bladesmith";
          case 20:
            return "Clean Shave Sgt";
          default:
            return "Bald Enforcer";
        }
      }

      async function loadLeaderboard() {
        try {
          const { provider } = await ensureProviderAndContract();

          const logs = await provider.getLogs({
            address: CONTRACT_ADDRESS,
            fromBlock: LEADERBOARD_FROM_BLOCK,
            toBlock: "latest"
          });

          const counts = new Map();

          for (const log of logs) {
            if (!log.topics || log.topics.length < 2) continue;

            try {
              const topic = log.topics[1];
              if (!topic || topic.length !== 66) continue;
              const addr = ethers.getAddress("0x" + topic.slice(26));
              const prev = counts.get(addr) || 0;
              counts.set(addr, prev + 1);
            } catch (e) {
              // ignore logs that don't decode cleanly to an address
            }
          }

          const rows = Array.from(counts.entries())
            .map(([wallet, votes]) => ({ wallet, votes }))
            .sort((a, b) => b.votes - a.votes)
            .slice(0, LEADERBOARD_MAX_ENTRIES);

          const tbody = $("leaderboardBody");
          if (!tbody) return;

          tbody.innerHTML = "";

          if (rows.length === 0) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 4;
            td.textContent = "No votes yet. Be the first to vote.";
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
          }

          const me = currentAccount ? currentAccount.toLowerCase() : null;

          rows.forEach((row, index) => {
            const tr = document.createElement("tr");
            if (me && row.wallet.toLowerCase() === me) {
              tr.classList.add("leaderboard-row-me");
            }

            const rankTd = document.createElement("td");
            rankTd.className = "rank-col";
            rankTd.textContent = (index + 1).toString();

            const titleTd = document.createElement("td");
            titleTd.className = "title-col";
            titleTd.textContent = getRankTitle(index + 1);

            const walletTd = document.createElement("td");
            walletTd.textContent =
              row.wallet.slice(0, 6) + "..." + row.wallet.slice(-4);

            const votesTd = document.createElement("td");
            votesTd.className = "votes-col";
            votesTd.textContent = row.votes.toLocaleString();

            tr.appendChild(rankTd);
            tr.appendChild(titleTd);
            tr.appendChild(walletTd);
            tr.appendChild(votesTd);
            tbody.appendChild(tr);
          });
        } catch (err) {
          console.error("Error loading leaderboard:", err);
          // If it fails, we just leave the existing table contents.
        }
      }

      // ==========================
      //  STATE REFRESH (ON-CHAIN)
      // ==========================

      async function refreshUserAndGlobalState() {
        if (!currentAccount) return;

        try {
          const { contract } = await ensureProviderAndContract();

          let totalVotesGlobal = 0;
          let targetVotes = DEFAULT_TARGET_VOTES;
          let maxVotesPerDay = 10;
          let votesLeft = null;
          let userTotalVotes = null;
          let votesToday = null;

          // Global totals
          try {
            const totalBn = await contract.totalVotesGlobal();
            totalVotesGlobal = Number(totalBn);
          } catch (e) {
            console.warn("totalVotesGlobal read failed", e);
          }

          // For this round, always use our front-end target
          targetVotes = DEFAULT_TARGET_VOTES;

          try {
            const maxBn = await contract.maxVotesPerDay();
            maxVotesPerDay = Number(maxBn);
          } catch (e) {
            console.warn("maxVotesPerDay read failed, using default 10", e);
          }

          // Per-user
          try {
            const info = await contract.getUserInfo(currentAccount);
            // [dayIndex, votesToday, totalVotes, tokensClaimed, votesLeft]
            votesToday = Number(info[1]);
            userTotalVotes = Number(info[2]);
            votesLeft = Number(info[4]);
          } catch (e) {
            console.warn("getUserInfo read failed, falling back", e);
            try {
              const leftBn = await contract.votesLeftToday(currentAccount);
              votesLeft = Number(leftBn);
            } catch (e2) {
              console.warn("votesLeftToday read failed", e2);
            }
            try {
              const totalBn = await contract.totalVotesOf(currentAccount);
              userTotalVotes = Number(totalBn);
            } catch (e3) {
              console.warn("totalVotesOf read failed", e3);
            }
          }

          // ===== Vote 2 logic =====
          const totalVotesRound = Math.max(
            0,
            totalVotesGlobal != null ? totalVotesGlobal - VOTE1_FINAL_TOTAL : 0
          );

          // Update stats UI
          const totalVotesEl = $("totalVotes");
          if (totalVotesEl) {
            totalVotesEl.textContent = totalVotesRound.toLocaleString();
          }

          const userTotalVotesEl = $("userTotalVotes");
          if (userTotalVotesEl) {
            userTotalVotesEl.textContent =
              userTotalVotes != null
                ? userTotalVotes.toLocaleString()
                : "-";
          }

          const votesTodayEl = $("votesToday");
          if (votesTodayEl) {
            if (votesLeft != null && maxVotesPerDay != null) {
              const used = Math.max(
                0,
                maxVotesPerDay - Number(votesLeft)
              );
              votesTodayEl.textContent = `${used}/${maxVotesPerDay}`;
            } else if (votesToday != null && maxVotesPerDay != null) {
              votesTodayEl.textContent = `${votesToday}/${maxVotesPerDay}`;
            } else {
              votesTodayEl.textContent = `0/${maxVotesPerDay}`;
            }
          }

          // Thermometer uses Vote 2 total
          updateThermometer(totalVotesRound, targetVotes);

          // Show/hide vote button *only* if we know they have 0 left.
          const voteBtn = $("voteButton");
          const usedMsg = $("usedAllVotesMessage");
          if (voteBtn && usedMsg) {
            if (votesLeft === 0) {
              voteBtn.classList.add("hidden");
              usedMsg.classList.remove("hidden");
              usedMsg.textContent =
                "You’ve used all votes for now. Come back later.";
            } else {
              voteBtn.classList.remove("hidden");
              usedMsg.classList.add("hidden");
            }
          }

          // Update leaderboard from logs (all-time)
          await loadLeaderboard();
        } catch (err) {
          console.error("Error reading user/global state:", err);
          // Soft fail: keep vote button visible so user can still try
          const voteBtn = $("voteButton");
          const usedMsg = $("usedAllVotesMessage");
          if (voteBtn && usedMsg) {
            voteBtn.classList.remove("hidden");
            usedMsg.classList.add("hidden");
          }
        }
      }

      // ==========================
      //  CONNECT FLOW
      // ==========================

      async function handleConnectClick() {
        setError("");
        setSuccess("");

        if (!window.ethereum) {
          setError("MetaMask not found. Please install it to continue.");
          return;
        }

        try {
          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts"
          });

          if (!accounts || !accounts.length) {
            setError("No wallet selected.");
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount; // for debugging

          // HTTP PoH gate first
          const pohResult = await checkPohOffchain(currentAccount);

          if (pohResult === true) {
            isPohVerified = true;
            showVotingSection();
            $("pohStatusYes").textContent = "Yes";

            // Init contract + state
            await ensureProviderAndContract();
            await refreshUserAndGlobalState();
          } else if (pohResult === false) {
            isPohVerified = false;
            showNotVerifiedSection();
            const verifyLink = $("verifyLink");
            if (verifyLink) {
              verifyLink.href = POH_PORTAL_URL;
            }
            setError(
              "This wallet is not Proof-of-Humanity verified. Use the Verify link to complete PoH."
            );
          } else {
            isPohVerified = null;
            showConnectSection();
            setError(
              "Could not check Proof of Humanity. Please try again in a moment."
            );
          }
        } catch (err) {
          console.error("Connect/init error:", err);
          setError("Failed to connect wallet. Check console for details.");
        }
      }

      // ==========================
      //  VOTE (ON-CHAIN POH)
      // ==========================

      async function onVoteClick() {
        setError("");
        setSuccess("");

        try {
          if (!window.ethereum) {
            setError("MetaMask not found.");
            return;
          }
          if (!currentAccount) {
            setError("Connect your wallet first.");
            return;
          }

          const { provider, contract } = await ensureProviderAndContract();

          const onLinea = await ensureOnLinea();
          if (!onLinea) {
            setError("Please switch your wallet network to Linea.");
            return;
          }

          // Soft UX guard: if HTTP PoH said "false", block.
          if (isPohVerified === false) {
            setError(
              "This wallet is not PoH verified via Linea. Complete PoH first."
            );
            return;
          }

          setVoteButtonBusy(true);

          // Get PoH signature from Linea signer API
          const sigRes = await fetch(
            `${POH_SIGNER_API_BASE}/${currentAccount}`
          );
          if (!sigRes.ok) {
            throw new Error(`PoH signer HTTP ${sigRes.status}`);
          }
          const rawSig = (await sigRes.text()).trim();
          if (!rawSig || rawSig === "0x") {
            throw new Error(
              "Empty PoH signature from Linea signer. Wallet may not be on-chain PoH verified yet."
            );
          }
          if (!rawSig.startsWith("0x")) {
            throw new Error("Invalid PoH signature format from Linea signer.");
          }
          const pohSignature = rawSig;

          // Send vote transaction
          const tx = await contract.vote(pohSignature);
          await tx.wait();

          setSuccess(
            "Vote successful! Your TATERZ claim + vote has been recorded."
          );
          await refreshUserAndGlobalState();
        } catch (err) {
          console.error("Vote tx error:", err);

          const rawMsg =
            err?.error?.message ||
            err?.data?.message ||
            err?.reason ||
            err?.message ||
            String(err ?? "");
          const lower = rawMsg.toLowerCase();

          if (
            err?.code === "ACTION_REJECTED" ||
            lower.includes("user rejected")
          ) {
            setError("Transaction rejected in wallet.");
          } else if (
            lower.includes("notpohverified") ||
            lower.includes("not poh verified")
          ) {
            setError(
              "This wallet is not PoH-verified according to Linea's on-chain verifier. Complete PoH with this wallet."
            );
          } else if (lower.includes("daily") && lower.includes("limit")) {
            setError("You’ve used all votes for now. Come back later.");
          } else if (
            lower.includes("not enough taterz") ||
            lower.includes("insufficient taterz")
          ) {
            setError(
              "Voting contract does not have enough TATERZ to pay rewards. Please contact the team."
            );
          } else if (
            lower.includes("ecdsa: invalid signature length") ||
            lower.includes("invalid signature")
          ) {
            setError(
              "Linea PoH signature was invalid. If you recently verified, give it a few minutes and try again. Otherwise re-do PoH with this wallet."
            );
          } else if (lower.includes("signer http")) {
            setError(
              "Could not fetch PoH signature from Linea signer API. Please try again shortly."
            );
          } else if (lower.includes("empty poh signature")) {
            setError(
              "Linea signer returned an empty PoH signature. This usually means the wallet is not registered yet. Re-do PoH with this wallet."
            );
          } else {
            setError("Vote transaction failed. Check console for details.");
          }
        } finally {
          setVoteButtonBusy(false);
        }
      }

      // ==========================
      //  WALLET EVENTS & AUTO-CONNECT
      // ==========================

      function setupWalletEventListeners() {
        if (!window.ethereum) return;

        window.ethereum.on("accountsChanged", (accounts) => {
          setError("");
          setSuccess("");

          if (!accounts || !accounts.length) {
            currentAccount = null;
            provider = null;
            signer = null;
            contract = null;
            isPohVerified = null;
            showConnectSection();
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount;
          // Re-run gate for the new account
          showConnectSection();
        });

        window.ethereum.on("chainChanged", async () => {
          if (currentAccount && isPohVerified) {
            try {
              await refreshUserAndGlobalState();
            } catch (e) {
              console.warn("Could not refresh after chain change", e);
            }
          }
        });
      }

      async function autoConnectIfPossible() {
        if (!window.ethereum) {
          showConnectSection();
          return;
        }

        try {
          const accounts = await window.ethereum.request({
            method: "eth_accounts"
          });

          if (!accounts || !accounts.length) {
            showConnectSection();
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount;

          // Auto-run PoH gate quietly
          const pohResult = await checkPohOffchain(currentAccount);
          if (pohResult === true) {
            isPohVerified = true;
            showVotingSection();
            $("pohStatusYes").textContent = "Yes";
            await ensureProviderAndContract();
            await refreshUserAndGlobalState();
          } else if (pohResult === false) {
            isPohVerified = false;
            showNotVerifiedSection();
            const verifyLink = $("verifyLink");
            if (verifyLink) {
              verifyLink.href = POH_PORTAL_URL;
            }
          } else {
            isPohVerified = null;
            showConnectSection();
          }
        } catch (err) {
          console.error("Auto-connect error:", err);
          showConnectSection();
        }
      }

      // ==========================
      //  BOOTSTRAP
      // ==========================

      window.addEventListener("load", () => {
        // Insert Vote button + "used all" text
        const voteAction = $("voteAction");
        if (voteAction) {
          const btn = document.createElement("button");
          btn.id = "voteButton";
          btn.className = "vote-btn";
          btn.type = "button";
          btn.setAttribute("aria-label", "Vote");
          btn.addEventListener("click", onVoteClick);
          voteAction.appendChild(btn);

          const usedMsg = document.createElement("div");
          usedMsg.id = "usedAllVotesMessage";
          usedMsg.className = "no-votes-text hidden";
          usedMsg.textContent =
            "You’ve used all votes for now. Come back later.";
          voteAction.appendChild(usedMsg);
        }

        const connectBtn = $("connectWalletButton");
        if (connectBtn) {
          connectBtn.addEventListener("click", handleConnectClick);
        }

        showConnectSection();
        setupWalletEventListeners();
        autoConnectIfPossible();
      });
    </script>
  </body>
</html>
