<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>DN Vote Station</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Vote on very serious topics, earn TATERZ" />

    <link rel="icon" href="assets/images/dnfavicon.ico" />

    <style>
      @font-face {
        font-family: "OverstreetBibleBold";
        src: url("assets/fonts/overstreetbiblebold.ttf") format("truetype");
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "OverstreetBibleBold", system-ui, -apple-system,
          BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #ffffff;
        background: url("assets/images/background2.png") center center / cover
          no-repeat fixed;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .page {
        width: 100%;
        max-width: 1200px;
        padding: 20px 16px 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      /* HEADER / LOGO BAR */
      .header {
        width: 100%;
        height: 100px;
        background: transparent;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 0;
      }

      .header-link {
        display: inline-block;
      }

      .header-logo {
        height: 120px;
        width: auto;
        transition: transform 0.3s ease;
      }

      .header-logo:hover {
        transform: scale(1.05);
      }

      /* TITLE */
      h1 {
        margin: 60px 0 40px;
        text-align: center;
        font-size: clamp(2.5rem, 5vw, 4.5rem);
        line-height: 1.1;
        text-transform: uppercase;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        color: #000000;
      }

      /* CONNECT SECTION */
      .connect-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      }

      .connect-btn {
        border: none;
        padding: 0;
        background: transparent;
        cursor: pointer;
        display: block;
        width: 260px;
        height: 80px;
        background-image: url("assets/images/connect.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .connect-btn:hover {
        background-image: url("assets/images/connecthover.png");
        transform: scale(1.15);
      }

      .connect-btn:active {
        transform: scale(0.98);
      }

      .connect-hover-text {
        margin-top: 16px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #f5f5f5;
        font-size: 2rem;
        opacity: 0;
        transform: translateY(8px);
        transition:
          opacity 0.2s ease-out,
          transform 0.2s ease-out;
        pointer-events: none;
      }

      .connect-wrapper:hover .connect-hover-text {
        opacity: 1;
        transform: translateY(0);
      }

      /* NOT VERIFIED STATE */
      .not-verified {
        margin-top: 24px;
        text-align: center;
        font-size: 1.4rem;
      }

      .verify-btn {
        margin-top: 12px;
        display: inline-block;
        width: 260px;
        height: 80px;
        background-image: url("assets/images/verifyhere.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: contain;
        border: none;
        cursor: pointer;
        text-decoration: none;
        transition:
          transform 0.15s ease-out,
          background-image 0.15s ease-out;
      }

      .verify-btn:hover {
        background-image: url("assets/images/verifyherehover.png");
        transform: scale(1.15);
      }

      .verify-btn:active {
        transform: scale(0.98);
      }

      /* VOTING STATION */
      .voting-station {
        margin-top: 20px;
        width: 100%;
        max-width: 600px;
        text-align: center;
        color: #ffffff;
      }

      .voting-layout {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        justify-content: center;
      }

      .voting-content {
        flex: 1;
        min-width: 0;
      }

      .voting-title {
        font-size: clamp(1.6rem, 3.2vw, 2.6rem);
        text-transform: uppercase;
        margin-bottom: 16px;
        text-shadow: 0 3px 6px rgba(0, 0, 0, 0.5);
        line-height: 1.15;
      }

      /* PoH status + rank pill */
      .poh-status {
        margin-bottom: 20px;
        font-size: 1.6rem;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: center;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      }

      .poh-status-label {
        color: #ffffff;
      }

      .poh-status-yes {
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 6px #000,
          0 0 10px #000;
      }

      .poh-rank {
        font-size: 1.6rem;
        padding: 4px 12px;
        border-radius: 999px;
        background: rgba(18, 206, 236, 0.2);
        border: 1px solid rgba(0, 255, 232, 0.7);
        color: #00ffe8;
        text-shadow:
          0 0 3px #000,
          0 0 8px #000,
          0 0 12px #000;
      }

      .vote-stats {
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-size: 1.4rem;
        margin-bottom: 24px;
      }

      .vote-stat-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(0, 0, 0, 0.45);
        padding: 10px 16px;
        border-radius: 10px;
      }

      .vote-stat-label {
        text-align: left;
      }

      .vote-stat-value {
        text-align: right;
      }

      .vote-action {
        margin-top: 10px;
        font-size: 1.6rem;
      }

      .no-votes-text {
        font-size: 1.6rem;
        opacity: 0.9;
      }

      /* YES / NO basic poll UI */
      .yn-panel {
        display: flex;
        gap: 12px;
        justify-content: center;
        margin-bottom: 18px;
        flex-wrap: wrap;
      }

      .yn-card {
        width: 240px;
        border-radius: 14px;
        padding: 18px 16px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.55);
      }

      .yn-card-yes {
        background: rgba(0, 255, 232, 0.22);
      }

      .yn-card-no {
        background: rgba(255, 0, 64, 0.22);
      }

      .yn-label {
        font-size: 1.8rem;
        text-transform: uppercase;
        opacity: 0.98;
        letter-spacing: 0.5px;
      }

      .yn-value {
        margin-top: 8px;
        font-size: 3.4rem;
        text-shadow:
          0 3px 6px rgba(0, 0, 0, 0.6),
          0 0 14px rgba(0, 0, 0, 0.35);
      }

      .yn-actions {
        display: flex;
        gap: 14px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .yn-btn {
        border: 1px solid rgba(255, 255, 255, 0.18);
        cursor: pointer;
        padding: 16px 20px;
        min-width: 200px;
        border-radius: 14px;
        font-family: inherit;
        font-size: 1.8rem;
        text-transform: uppercase;
        color: #ffffff;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.55);
        transition: transform 0.15s ease-out, opacity 0.15s ease-out;
      }

      .yn-btn:hover {
        transform: scale(1.06);
      }

      .yn-btn:active {
        transform: scale(0.98);
      }

      .yn-btn-yes {
        background: rgba(0, 255, 232, 0.22);
      }

      .yn-btn-no {
        background: rgba(255, 0, 64, 0.22);
      }

      /* LEADERBOARD */
      .leaderboard {
        margin-top: 40px;
        width: 100%;
        max-width: 600px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 16px;
        padding: 16px 20px 24px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.8);

        max-height: 500px;
        overflow-y: auto;
      }

      .leaderboard-title {
        font-size: 1.8rem;
        text-transform: uppercase;
        margin-bottom: 12px;
        text-align: center;
      }

      .leaderboard-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 1.2rem;
      }

      .leaderboard-table th,
      .leaderboard-table td {
        padding: 8px 10px;
        text-align: left;
      }

      .leaderboard-table th {
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        opacity: 0.9;
      }

      .leaderboard-table tr:nth-child(even) td {
        background: rgba(255, 255, 255, 0.03);
      }

      .leaderboard-table td.rank-col {
        width: 40px;
      }

      .leaderboard-table td.title-col {
        width: 200px;
      }

      .leaderboard-table td.votes-col {
        text-align: right;
        width: 120px;
      }

      .leaderboard-row-me td {
        background: rgba(18, 206, 236, 0.18) !important;
        font-weight: 600;
      }

      @media (max-width: 600px) {
        .header {
          height: 80px;
        }

        .header-logo {
          height: 60px;
        }

        .connect-btn {
          width: 220px;
          height: 70px;
        }

        h1 {
          margin-top: 40px;
        }

        .connect-hover-text {
          font-size: 1.6rem;
        }

        .vote-stats {
          font-size: 1.2rem;
        }

        .poh-status {
          font-size: 1.4rem;
        }

        .voting-layout {
          flex-direction: column;
          align-items: center;
        }

        .yn-card {
          width: 220px;
        }

        .yn-label {
          font-size: 1.6rem;
        }

        .yn-value {
          font-size: 3rem;
        }

        .yn-btn {
          font-size: 1.6rem;
          min-width: 190px;
        }
      }

      .hidden {
        display: none !important;
      }

      #errorBox {
        margin-top: 12px;
        color: #ffb3b3;
        text-shadow: 0 0 6px #000;
        display: none;
      }

      #successBox {
        margin-top: 8px;
        color: #b3ffd2;
        text-shadow: 0 0 6px #000;
        display: none;
      }
    </style>
  </head>

  <body>
    <div class="page">
      <header class="header">
        <a
          href="https://www.davydonothing.com"
          target="_blank"
          rel="noopener noreferrer"
          class="header-link"
        >
          <img
            src="assets/images/dnlogo2.png"
            alt="DN Brotato logo"
            class="header-logo"
          />
        </a>
      </header>

      <h1>DN Voting Platform</h1>

      <div class="connect-wrapper" id="connectSection">
        <button
          class="connect-btn"
          id="connectWalletButton"
          aria-label="Connect Wallet"
        ></button>

        <div class="connect-hover-text">
          <p>Connect your wallet to vote on SERIOUS topics</p>
        </div>
      </div>

      <div class="not-verified hidden" id="notVerifiedSection">
        <p>This wallet is not PoH verified yet.</p>
        <a
          href="#"
          target="_blank"
          rel="noopener noreferrer"
          class="verify-btn"
          id="verifyLink"
          aria-label="Verify PoH"
        ></a>
      </div>

      <div class="voting-station hidden" id="votingSection">
        <div class="voting-layout">
          <div class="voting-content">
            <div class="voting-title">
              Will Linea do the right thing with Exponent cheaters
            </div>

            <div class="poh-status">
              <span class="poh-status-label">Proof of Humanity verified:</span>
              <span class="poh-status-yes" id="pohStatusYes">Yes</span>
              <span class="poh-rank hidden" id="userRankLabel"></span>
            </div>

            <div class="yn-panel" id="ynPanel">
              <div class="yn-card yn-card-yes">
                <div class="yn-label">Yes</div>
                <div class="yn-value" id="yesVotes">0</div>
              </div>

              <div class="yn-card yn-card-no">
                <div class="yn-label">No</div>
                <div class="yn-value" id="noVotes">0</div>
              </div>
            </div>

            <div class="vote-stats">
              <div class="vote-stat-row">
                <div class="vote-stat-label">Votes this round</div>
                <div class="vote-stat-value" id="totalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Your total votes</div>
                <div class="vote-stat-value" id="userTotalVotes">0</div>
              </div>

              <div class="vote-stat-row">
                <div class="vote-stat-label">Votes today</div>
                <div class="vote-stat-value" id="votesToday">0/10</div>
              </div>
            </div>

            <div class="vote-action" id="voteAction"></div>

            <div id="errorBox" class="no-votes-text"></div>
            <div id="successBox" class="no-votes-text"></div>
          </div>
        </div>
      </div>

      <div class="leaderboard" id="leaderboardSection">
        <div class="leaderboard-title">Top Voters</div>
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th class="rank-col">#</th>
              <th class="title-col">Title</th>
              <th>Wallet</th>
              <th class="votes-col">Total Votes</th>
            </tr>
          </thead>
          <tbody id="leaderboardBody">
            <tr>
              <td colspan="4">No votes yet. Be the first to vote.</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>

    <script>
      // ========= CONFIG =========
      const CONTRACT_ADDRESS = "0xBE817fd849FbF8DBd07840F2F3a89F2D649994A3";

      const CONTRACT_ABI = [
        "function vote(bytes signature)",
        "function maxVotesPerDay() view returns (uint8)",
        "function votesLeftToday(address user) view returns (uint256)",
        "function totalVotesOf(address user) view returns (uint256)",
        "function getUserInfo(address user) view returns (uint64 dayIndex, uint8 votesToday, uint256 totalVotes, uint256 tokensClaimed, uint8 votesLeft)"
      ];

      const POH_API_BASE = "https://poh-api.linea.build/poh/v2";
      const POH_SIGNER_API_BASE = "https://poh-signer-api.linea.build/poh/v2";
      const POH_PORTAL_URL =
        "https://linea.build/hub/apps/sumsub-reusable-identity";

      const LINEA_CHAIN_ID = 59144n;

      // Vercel functions
      const API_VOTES = "/api/votes";
      const API_VOTE = "/api/vote";

      // Leaderboard settings (unchanged)
      const LEADERBOARD_MAX_ENTRIES = 100;
      const LEADERBOARD_FROM_BLOCK = 0n;

      // ========= GLOBAL STATE =========
      let provider = null;
      let signer = null;
      let contract = null;
      let currentAccount = null;
      let isPohVerified = null;

      function $(id) {
        return document.getElementById(id);
      }

      // ========= UI HELPERS =========
      function showConnectSection() {
        $("connectSection")?.classList.remove("hidden");
        $("notVerifiedSection")?.classList.add("hidden");
        $("votingSection")?.classList.add("hidden");
      }

      function showNotVerifiedSection() {
        $("connectSection")?.classList.add("hidden");
        $("notVerifiedSection")?.classList.remove("hidden");
        $("votingSection")?.classList.add("hidden");
      }

      function showVotingSection() {
        $("connectSection")?.classList.add("hidden");
        $("notVerifiedSection")?.classList.add("hidden");
        $("votingSection")?.classList.remove("hidden");
      }

      function setError(message) {
        const el = $("errorBox");
        const successEl = $("successBox");
        if (successEl) {
          successEl.textContent = "";
          successEl.style.display = "none";
        }
        if (!el) return;
        if (!message) {
          el.textContent = "";
          el.style.display = "none";
        } else {
          el.textContent = message;
          el.style.display = "block";
        }
      }

      function setSuccess(message) {
        const el = $("successBox");
        const errorEl = $("errorBox");
        if (errorEl) {
          errorEl.textContent = "";
          errorEl.style.display = "none";
        }
        if (!el) return;
        if (!message) {
          el.textContent = "";
          el.style.display = "none";
        } else {
          el.textContent = message;
          el.style.display = "block";
        }
      }

      function setVoteButtonBusy(isBusy) {
        const yesBtn = $("voteYesButton");
        const noBtn = $("voteNoButton");
        [yesBtn, noBtn].forEach((btn) => {
          if (!btn) return;
          btn.disabled = isBusy;
          btn.style.opacity = isBusy ? "0.6" : "1";
        });
      }

      // ========= ETH HELPERS =========
      async function ensureProviderAndContract() {
        if (!window.ethereum) throw new Error("MetaMask not found");
        if (!provider) provider = new ethers.BrowserProvider(window.ethereum);
        if (!signer) signer = await provider.getSigner();
        if (!contract)
          contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        return { provider, signer, contract };
      }

      async function ensureOnLinea() {
        if (!window.ethereum) return false;
        if (!provider) provider = new ethers.BrowserProvider(window.ethereum);
        const net = await provider.getNetwork();
        return net.chainId === LINEA_CHAIN_ID;
      }

      // ========= POH =========
      async function checkPohOffchain(address) {
        try {
          const res = await fetch(`${POH_API_BASE}/${address}`);
          if (!res.ok) throw new Error(`PoH HTTP ${res.status}`);
          const text = (await res.text()).trim();
          return text === "true";
        } catch (err) {
          console.error("PoH API error:", err);
          return null;
        }
      }

      // ========= GLOBAL TOTALS (API) =========
      async function fetchGlobalTotals() {
        const res = await fetch(API_VOTES, { method: "GET" });
        if (!res.ok) throw new Error(`votes api ${res.status}`);
        const data = await res.json();
        return {
          yes: Number(data?.yes || 0),
          no: Number(data?.no || 0),
          round: Number(data?.round || 0)
        };
      }

      async function renderGlobalTotals() {
        try {
          const totals = await fetchGlobalTotals();
          $("yesVotes").textContent = totals.yes.toLocaleString();
          $("noVotes").textContent = totals.no.toLocaleString();
          $("totalVotes").textContent = totals.round.toLocaleString();
        } catch (e) {
          console.warn("Failed to render global totals:", e);
        }
      }

      async function recordVoteIntent({ txHash, wallet, choice }) {
        const res = await fetch(API_VOTE, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ txHash, wallet, choice })
        });
        if (!res.ok) {
          const t = await res.text().catch(() => "");
          throw new Error(`vote api ${res.status} ${t}`);
        }
        return res.json();
      }

      // ========= LEADERBOARD (unchanged) =========
      async function fetchAllLogs(provider, address, fromBlock, toBlock) {
        let startBlock =
          typeof fromBlock === "bigint" ? fromBlock : BigInt(fromBlock);
        let endBlock =
          typeof toBlock === "bigint" ? toBlock : BigInt(toBlock);

        const allLogs = [];

        async function fetchRange(start, end) {
          if (end < start) return;
          try {
            const partial = await provider.getLogs({
              address,
              fromBlock: start,
              toBlock: end
            });
            allLogs.push(...partial);
          } catch (err) {
            const msg = (err?.message || "").toLowerCase();
            if (msg.includes("more than 10000 results")) {
              const span = end - start;
              if (span <= 0n) return;
              const mid = start + (span >> 1n);
              await fetchRange(start, mid);
              await fetchRange(mid + 1n, end);
            } else {
              console.error("Error fetching logs range", start, end, err);
            }
          }
        }

        await fetchRange(startBlock, endBlock);
        return allLogs;
      }

      function getRankTitle(rank) {
        switch (rank) {
          case 1:
            return "Follicle Liquidatooor";
          case 2:
            return "Hairline Rugpuller";
          case 3:
            return "The Buzzcut Butcher";
          case 4:
            return "Scalp Sniper";
          case 5:
            return "Chrome Dome Degen";
          case 6:
            return "The Clippersmith";
          case 7:
            return "The Bald Bringer";
          case 8:
            return "Harbinger of Hair Loss";
          case 9:
            return "The Hairline Eradicator";
          case 10:
            return "Supreme Scalp Sacrificer";
          case 11:
            return "The No-Hair Enabler";
          case 12:
            return "Clipper Kingpin";
          case 13:
            return "Follicle Doom Dealer";
          case 14:
            return "Clean Cut Kingmaker";
          case 15:
            return "Final Strand Supervisor";
          case 16:
            return "Commander of Clippers";
          case 17:
            return "Buzzcut Broker";
          case 18:
            return "Final Shave Boss";
          case 19:
            return "DN Bladesmith";
          case 20:
            return "Clean Shave Sgt";
          default:
            return "Bald Enforcer";
        }
      }

      async function loadLeaderboard() {
        try {
          const { provider } = await ensureProviderAndContract();

          let latestBlock = await provider.getBlockNumber();
          if (typeof latestBlock === "number") latestBlock = BigInt(latestBlock);

          const logs = await fetchAllLogs(
            provider,
            CONTRACT_ADDRESS,
            LEADERBOARD_FROM_BLOCK,
            latestBlock
          );

          const counts = new Map();

          for (const log of logs) {
            if (!log.topics || log.topics.length < 2) continue;
            try {
              const topic = log.topics[1];
              if (!topic || topic.length !== 66) continue;
              const addr = ethers.getAddress("0x" + topic.slice(26));
              const prev = counts.get(addr) || 0;
              counts.set(addr, prev + 1);
            } catch {}
          }

          const rows = Array.from(counts.entries())
            .map(([wallet, votes]) => ({ wallet, votes }))
            .sort((a, b) => b.votes - a.votes)
            .slice(0, LEADERBOARD_MAX_ENTRIES);

          const tbody = $("leaderboardBody");
          if (!tbody) return;

          tbody.innerHTML = "";

          if (rows.length === 0) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 4;
            td.textContent = "No votes yet. Be the first to vote.";
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
          }

          const me = currentAccount ? currentAccount.toLowerCase() : null;

          rows.forEach((row, index) => {
            const tr = document.createElement("tr");
            if (me && row.wallet.toLowerCase() === me) tr.classList.add("leaderboard-row-me");

            const rankTd = document.createElement("td");
            rankTd.className = "rank-col";
            rankTd.textContent = (index + 1).toString();

            const titleTd = document.createElement("td");
            titleTd.className = "title-col";
            titleTd.textContent = getRankTitle(index + 1);

            const walletTd = document.createElement("td");
            walletTd.textContent =
              row.wallet.slice(0, 6) + "..." + row.wallet.slice(-4);

            const votesTd = document.createElement("td");
            votesTd.className = "votes-col";
            votesTd.textContent = row.votes.toLocaleString();

            tr.appendChild(rankTd);
            tr.appendChild(titleTd);
            tr.appendChild(walletTd);
            tr.appendChild(votesTd);
            tbody.appendChild(tr);
          });
        } catch (err) {
          console.error("Error loading leaderboard:", err);
        }
      }

      // ========= STATE REFRESH =========
      async function refreshUserAndGlobalState() {
        if (!currentAccount) return;

        try {
          const { contract } = await ensureProviderAndContract();

          let maxVotesPerDay = 10;
          let votesLeft = null;
          let userTotalVotes = null;
          let votesToday = null;

          try {
            const maxBn = await contract.maxVotesPerDay();
            maxVotesPerDay = Number(maxBn);
          } catch {}

          try {
            const info = await contract.getUserInfo(currentAccount);
            votesToday = Number(info[1]);
            userTotalVotes = Number(info[2]);
            votesLeft = Number(info[4]);
          } catch {
            try {
              const leftBn = await contract.votesLeftToday(currentAccount);
              votesLeft = Number(leftBn);
            } catch {}
            try {
              const totalBn = await contract.totalVotesOf(currentAccount);
              userTotalVotes = Number(totalBn);
            } catch {}
          }

          await renderGlobalTotals();

          $("userTotalVotes").textContent =
            userTotalVotes != null ? userTotalVotes.toLocaleString() : "-";

          if (votesLeft != null && maxVotesPerDay != null) {
            const used = Math.max(0, maxVotesPerDay - Number(votesLeft));
            $("votesToday").textContent = `${used}/${maxVotesPerDay}`;
          } else if (votesToday != null && maxVotesPerDay != null) {
            $("votesToday").textContent = `${votesToday}/${maxVotesPerDay}`;
          } else {
            $("votesToday").textContent = `0/${maxVotesPerDay}`;
          }

          const yesBtn = $("voteYesButton");
          const noBtn = $("voteNoButton");
          const usedMsg = $("usedAllVotesMessage");

          if (usedMsg) {
            if (votesLeft === 0) {
              yesBtn?.classList.add("hidden");
              noBtn?.classList.add("hidden");
              usedMsg.classList.remove("hidden");
              usedMsg.textContent = "You’ve used all votes for now. Come back later.";
            } else {
              yesBtn?.classList.remove("hidden");
              noBtn?.classList.remove("hidden");
              usedMsg.classList.add("hidden");
            }
          }

          await loadLeaderboard();
        } catch (err) {
          console.error("refreshUserAndGlobalState error:", err);
        }
      }

      // ========= CONNECT =========
      async function handleConnectClick() {
        setError("");
        setSuccess("");

        if (!window.ethereum) {
          setError("MetaMask not found. Please install it to continue.");
          return;
        }

        try {
          const accounts = await window.ethereum.request({
            method: "eth_requestAccounts"
          });

          if (!accounts || !accounts.length) {
            setError("No wallet selected.");
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount;

          const pohResult = await checkPohOffchain(currentAccount);

          if (pohResult === true) {
            isPohVerified = true;
            showVotingSection();
            $("pohStatusYes").textContent = "Yes";
            await ensureProviderAndContract();
            await refreshUserAndGlobalState();
          } else if (pohResult === false) {
            isPohVerified = false;
            showNotVerifiedSection();
            $("verifyLink").href = POH_PORTAL_URL;
            setError(
              "This wallet is not Proof-of-Humanity verified. Use the Verify link to complete PoH."
            );
          } else {
            isPohVerified = null;
            showConnectSection();
            setError("Could not check Proof of Humanity. Please try again in a moment.");
          }
        } catch (err) {
          console.error("Connect/init error:", err);
          setError("Failed to connect wallet. Check console for details.");
        }
      }

      // ========= VOTE =========
      async function onVoteClick(choice) {
        setError("");
        setSuccess("");

        try {
          if (!window.ethereum) {
            setError("MetaMask not found.");
            return;
          }
          if (!currentAccount) {
            setError("Connect your wallet first.");
            return;
          }

          const { contract } = await ensureProviderAndContract();

          const onLinea = await ensureOnLinea();
          if (!onLinea) {
            setError("Please switch your wallet network to Linea.");
            return;
          }

          if (isPohVerified === false) {
            setError("This wallet is not PoH verified via Linea. Complete PoH first.");
            return;
          }

          setVoteButtonBusy(true);

          const sigRes = await fetch(`${POH_SIGNER_API_BASE}/${currentAccount}`);
          if (!sigRes.ok) throw new Error(`PoH signer HTTP ${sigRes.status}`);
          const rawSig = (await sigRes.text()).trim();

          if (!rawSig || rawSig === "0x") throw new Error("Empty PoH signature from Linea signer.");
          if (!rawSig.startsWith("0x")) throw new Error("Invalid PoH signature format from Linea signer.");

          const tx = await contract.vote(rawSig);
          const receipt = await tx.wait();

          const txHash = receipt?.hash || receipt?.transactionHash || tx.hash;

          // Record globally in Redis (serverless)
          const apiResult = await recordVoteIntent({
            txHash,
            wallet: currentAccount,
            choice
          });

          // Immediately reflect server truth (includes other users)
          if (apiResult && typeof apiResult.yes !== "undefined") {
            $("yesVotes").textContent = Number(apiResult.yes || 0).toLocaleString();
            $("noVotes").textContent = Number(apiResult.no || 0).toLocaleString();
            $("totalVotes").textContent = Number(apiResult.round || 0).toLocaleString();
          } else {
            await renderGlobalTotals();
          }

          setSuccess("Vote successful! Your TATERZ claim + vote has been recorded.");

          await refreshUserAndGlobalState();
        } catch (err) {
          console.error("Vote tx error:", err);

          const rawMsg =
            err?.error?.message ||
            err?.data?.message ||
            err?.reason ||
            err?.message ||
            String(err ?? "");
          const lower = rawMsg.toLowerCase();

          if (err?.code === "ACTION_REJECTED" || lower.includes("user rejected")) {
            setError("Transaction rejected in wallet.");
          } else if (lower.includes("notpohverified") || lower.includes("not poh verified")) {
            setError(
              "This wallet is not PoH-verified according to Linea's on-chain verifier. Complete PoH with this wallet."
            );
          } else if (lower.includes("daily") && lower.includes("limit")) {
            setError("You’ve used all votes for now. Come back later.");
          } else if (lower.includes("not enough taterz") || lower.includes("insufficient taterz")) {
            setError("Voting contract does not have enough TATERZ to pay rewards. Please contact the team.");
          } else if (lower.includes("invalid signature")) {
            setError("Linea PoH signature was invalid. If you recently verified, give it a few minutes and try again.");
          } else {
            setError("Vote transaction failed. Check console for details.");
          }
        } finally {
          setVoteButtonBusy(false);
        }
      }

      function setupWalletEventListeners() {
        if (!window.ethereum) return;

        window.ethereum.on("accountsChanged", (accounts) => {
          setError("");
          setSuccess("");

          if (!accounts || !accounts.length) {
            currentAccount = null;
            provider = null;
            signer = null;
            contract = null;
            isPohVerified = null;
            showConnectSection();
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount;
          showConnectSection();
        });

        window.ethereum.on("chainChanged", async () => {
          if (currentAccount && isPohVerified) {
            try {
              await refreshUserAndGlobalState();
            } catch {}
          }
        });
      }

      async function autoConnectIfPossible() {
        if (!window.ethereum) {
          showConnectSection();
          return;
        }

        try {
          const accounts = await window.ethereum.request({ method: "eth_accounts" });

          if (!accounts || !accounts.length) {
            showConnectSection();
            return;
          }

          currentAccount = accounts[0];
          window.currentAccount = currentAccount;

          const pohResult = await checkPohOffchain(currentAccount);
          if (pohResult === true) {
            isPohVerified = true;
            showVotingSection();
            $("pohStatusYes").textContent = "Yes";
            await ensureProviderAndContract();
            await refreshUserAndGlobalState();
          } else if (pohResult === false) {
            isPohVerified = false;
            showNotVerifiedSection();
            $("verifyLink").href = POH_PORTAL_URL;
          } else {
            isPohVerified = null;
            showConnectSection();
          }
        } catch (err) {
          console.error("Auto-connect error:", err);
          showConnectSection();
        }
      }

      // ========= BOOTSTRAP =========
      window.addEventListener("load", async () => {
        const voteAction = $("voteAction");
        if (voteAction) {
          const actions = document.createElement("div");
          actions.className = "yn-actions";

          const yesBtn = document.createElement("button");
          yesBtn.id = "voteYesButton";
          yesBtn.className = "yn-btn yn-btn-yes";
          yesBtn.type = "button";
          yesBtn.textContent = "Vote Yes";
          yesBtn.addEventListener("click", () => onVoteClick("yes"));

          const noBtn = document.createElement("button");
          noBtn.id = "voteNoButton";
          noBtn.className = "yn-btn yn-btn-no";
          noBtn.type = "button";
          noBtn.textContent = "Vote No";
          noBtn.addEventListener("click", () => onVoteClick("no"));

          actions.appendChild(yesBtn);
          actions.appendChild(noBtn);
          voteAction.appendChild(actions);

          const usedMsg = document.createElement("div");
          usedMsg.id = "usedAllVotesMessage";
          usedMsg.className = "no-votes-text hidden";
          usedMsg.textContent = "You’ve used all votes for now. Come back later.";
          voteAction.appendChild(usedMsg);
        }

        // Render totals before connect (global)
        await renderGlobalTotals();

        // Poll so everyone sees updates without refresh
        setInterval(() => {
          renderGlobalTotals();
        }, 5000);

        $("connectWalletButton")?.addEventListener("click", handleConnectClick);

        showConnectSection();
        setupWalletEventListeners();
        autoConnectIfPossible();
      });
    </script>
  </body>
</html>
